        
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- "$Id: SORTI.html 75 2018-01-12 15:48:16Z coats $" -->
<META NAME="MSSmartTagsPreventParsing" CONTENT="TRUE"> 
<TITLE> SORTI*() </TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" 
      TOPMARGIN="15" 
      MARGINHEIGHT="15" 
      LEFTMARGIN="15" 
      MARGINWIDTH="15">

<H1>    The SORTI and qsorti routines </H1>


<H2> Fortran version: </H2>

    <BLOCKQUOTE>
    <STRONG>Fortran-90 generic routine <VAR>SORTI()</VAR> for
    I/O&nbsp;API-3.2:</STRONG>:  compiler selects the appropriate
    type-specific form depending upon the number and types of the 
    <CODE>INTEGER</CODE>, <CODE>INTEGER*8</CODE> or <CODE>REAL</CODE> key-lists.
    Note that the <CODE>SORTIN*(&nbsp;N[8],&nbsp;M[8],&nbsp;INDX[8],&nbsp;CLIST&nbsp;)</CODE> forms do the sort
    on  the basis of the first <CODE>M</CODE> or <CODE>M8</CODE> characters in the strings
    in the <CODE>CLIST</CODE> array and ignore the remainder of each
    table-entry.
    <P>
    For I/O&nbsp;API Versions&nbsp;3.1 and before, the generic form
    <VAR>SORTI()</VAR>, <VAR>SORTIC8()</VAR>, the <VAR>SORTL*()</VAR>
    and the <VAR>SORTINC*()</VAR> are not available.
    </BLOCKQUOTE>

<PRE>
    SUBROUTINE SORTI( N,      INDX,  LIST1[, ... ] )
    SUBROUTINE SORTI( N,      INDX,  CLIST )
    SUBROUTINE SORTI( N8,     INDX8, CLIST )
    SUBROUTINE SORTI( N,  M,  INDX,  CLIST )
    SUBROUTINE SORTI( N8, M8, INDX,  CLIST )
</PRE><P> 

<STRONG>Type-specific forms:</STRONG>
<PRE>
    SUBROUTINE SORTIC(   N,      INDX,  CLIST )
    SUBROUTINE SORTIC4(  N,      INDX,  CLIST )
    SUBROUTINE SORTIC8(  N8,     INDX8, CLIST )
    SUBROUTINE SORTINC4( N,  M,  INDX,  CLIST )
    SUBROUTINE SORTINC8( N8, M8, INDX8, CLIST )

    SUBROUTINE SORTI1( N, INDX, ILIST1 )
    SUBROUTINE SORTI2( N, INDX, ILIST1, ILIST2 )
    SUBROUTINE SORTI3( N, INDX, ILIST1, ILIST2, ILIST3 )
    SUBROUTINE SORTI4( N, INDX, ILIST1, ILIST2, ILIST3, ILIST4 )

    SUBROUTINE SORTL1( N, INDX, LLIST1 )
    SUBROUTINE SORTL2( N, INDX, LLIST1, LLIST2 )
    SUBROUTINE SORTL3( N, INDX, LLIST1, LLIST2, LLIST3 )
    SUBROUTINE SORTL4( N, INDX, LLIST1, LLIST2, LLIST3, LLIST4 )

    SUBROUTINE SORTR1( N, INDX, RLIST1 )
    SUBROUTINE SORTR2( N, INDX, RLIST1, RLIST2 )
    SUBROUTINE SORTR3( N, INDX, RLIST1, RLIST2, RLIST3 )
    SUBROUTINE SORTR4( N, INDX, RLIST1, RLIST2, RLIST3, RLIST4 )

        INTEGER  , INTENT(IN   ) :: N           !  table size
        INTEGER*8, INTENT(IN   ) :: N8          !  table size (for SORT*8() )
        INTEGER  , INTENT(IN   ) :: M           !  significant number of columns in table
        INTEGER*8, INTENT(IN   ) :: M8          !  significant number of columns in table
        INTEGER  , INTENT(INOUT) :: INDX ( N )  !  Fortran-subscript 1...N string-table to be sorted
        INTEGER*8, INTENT(INOUT) :: INDX8( N )  !  Fortran-subscript 1...N string-table to be sorted

        CHARACTER*(*), INTENT(IN   ) :: CLIST     !  table of key strings

        INTEGER  , INTENT(IN   ) :: ILIST1( N ) !  table of first  key-tuple components
        INTEGER  , INTENT(IN   ) :: ILIST2( N ) !  table of second key-tuple components
        INTEGER  , INTENT(IN   ) :: ILIST3( N ) !  table of third  key-tuple components
        INTEGER  , INTENT(IN   ) :: ILIST4( N ) !  table of fourth key-tuple components

        INTEGER*8, INTENT(IN   ) :: LLIST1( N ) !  table of first  key-tuple components
        INTEGER*8, INTENT(IN   ) :: LLIST2( N ) !  table of second key-tuple components
        INTEGER*8, INTENT(IN   ) :: LLIST3( N ) !  table of third  key-tuple components
        INTEGER*8, INTENT(IN   ) :: LLIST4( N ) !  table of fourth key-tuple components

        REAL     , INTENT(IN   ) :: RLIST1( N ) !  table of first  key-tuple components
        REAL     , INTENT(IN   ) :: RLIST2( N ) !  table of second key-tuple components
        REAL     , INTENT(IN   ) :: RLIST3( N ) !  table of third  key-tuple components
        REAL     , INTENT(IN   ) :: RLIST4( N ) !  table of fourth key-tuple components
</PRE><P> 

<H2> C version:   </H2>
<PRE>
    void qsortic( int        n,          /** number of elements **/
                  int        ind[],      /** index-array **/
                  const char tblc[],     /** first  key-component in tuple   **/
                  const int  k )         /** key-length as a Fortran string  **/
                  
    void qsorti1( int        n,          /** Dimension for indx, list **/
                  int        indx [],    /** subscript table **/
                  const int  list1[] );  /** key table to be sorted **/

    void qsorti2( int        n,          /** Dimension for indx, list **/
                  int        indx [],    /** subscript table **/
                  const int  list1[] ,   /** 2-key table to be sorted **/
                  const int  list2[] ) ;

    void qsorti3( int        n,          /** Dimension for indx, list **/
                  int        indx [],    /** subscript table **/
                  const int  list1[] ,   /** 3-key table to be sorted **/
                  const int  list2[] ,
                  const int  list3[] ) ;

    void qsorti4( int        n,          /** Dimension for indx, list **/
                  int        indx [],    /** subscript table **
                  const int  list1[] ,   /** 4-key table to be sorted **/
                  const int  list2[] ,
                  const int  list3[] ,
                  const int  list4[] ) ;
                  
    void qsortl1( int           n,          /** Dimension for indx, list **/
                  int           indx [],    /** subscript table **/
                  const int64_t list1[] );  /** key table to be sorted **/

    void qsortl2( int           n,          /** Dimension for indx, list **/
                  int           indx [],    /** subscript table **/
                  const int64_t list1[] ,   /** 2-key table to be sorted **/
                  const int64_t list2[] ) ;

    void qsortl3( int           n,          /** Dimension for indx, list **/
                  int           indx [],    /** subscript table **/
                  const int64_t list1[] ,   /** 3-key table to be sorted **/
                  const int64_t list2[] ,
                  const int64_t list3[] ) ;

    void qsortl4( int           n,          /** Dimension for indx, list **/
                  int           indx [],    /** subscript table **
                  const int64_t list1[] ,   /** 4-key table to be sorted **/
                  const int64_t list2[] ,
                  const int64_t list3[] ,
                  const int64_t list4[] ) ;

    void qsortr1( int         n,          /** Dimension for indx, list **/
                  int         indx [],    /** subscript table **/
                  const float list1[] );  /** key table to be sorted **/

    void qsortr2( int         n,          /** Dimension for indx, list **/
                  int         indx [],    /** subscript table **/
                  const float list1[] ,   /** 2-key table to be sorted **/
                  const float list2[] ) ;

    void qsortr3( int         n,          /** Dimension for indx, list **/
                  int         indx [],    /** subscript table **/
                  const float list1[] ,   /** 3-key table to be sorted **/
                  const float list2[] ,
                  const float list3[] ) ;

    void qsortr4( int         n,          /** Dimension for indx, list **/
                  int         indx [],    /** subscript table **
                  const float list1[] ,   /** 4-key table to be sorted **/
                  const float list2[] ,
                  const float list3[] ,
                  const float list4[] ) ;

</PRE><P> 

<H2> Summary: </H2>

    Sort an index-table to the indicated key-tuple table, so that the
    result will be in increasing order.
    <P> 

    See also <A HREF = "FINDS.html"> FINDC, FIND1, FIND2, FIND3, FIND4,  
    FINDR1, FINDR2, FINDR3, FINDR4</A> for lookups according to sorted 
    key-tuple tables, and <A HREF = "LOCATS.html"> LOCATC, LOCAT1,
    LOCAT2, LOCAT3, LOCAT4, LOCATR1, LOCATR2, LOCATR3, LOCATR4</A> for 
    insertions into sorted key-tuple tables.
    <P>

    For Fortran-90 generic interface <CODE>SORTI()</CODE>, declarations
    and interface checking:    
    <PRE>
    <A HREF = "M3UTILIO.html">USE M3UTILIO</A>
    </PRE><P>


<H2> Preconditions:   </H2>

    Table &lt;N, INDX, ... &gt; to be sorted is initialized to 1, ..., N
<P> 


<H2> Fortran Usage: </H2>

    Construct a sorted index to a set of unsorted 3-tuple tables 
    {LIST1,LIST2,LIST3} with an associated data array DATA1, DATA2, ..., and
    use it to construct a set of sorted 3-tuple tables
    {SORTED1,SORTED2,SORTED3} and their related sorted data:
<PRE>
    ...
    USE M3UTILIO
    ...
    INTEGER       N
    PARAMETER   ( N = ...
    ...
    INTEGER       I
    INTEGER       INDX ( N )   !  index array to be sorted
    INTEGER       LIST1( N )   !  input unsorted 3-tuple table
    INTEGER       LIST2( N )   !  input unsorted 3-tuple table
    INTEGER       LIST3( N )   !  input unsorted 3-tuple table
    REAL          DATA1( N )   !  input data table with same subscripting
    REAL          DATA2( N )   !  as &lt;LIST1,LIST2,LIST3&gt;
    ...
    DATA          LIST1 / 1983, 1980, 1988, 1988, 1990, ...
    DATA          LIST2 /    1,    5,    4,   11,    7, ...
    DATA          LIST3 /   10,    3,   15,   19,   20, ...
    INTEGER       SORTED1( N ) !  sorted 3-tuple table
    INTEGER       SORTED2( N ) !  sorted 3-tuple table
    INTEGER       SORTED3( N ) !  sorted 3-tuple table
    REAL          SDATA1( N ) !  sorted data table
    REAL          SDATA2( N ) !  sorted data table
    ...
    DO  I = 1, N	!  initialize INDX array
        INDX( I ) = I
    END DO
    CALL SORTI3( N, INDX, LIST1, LIST2, LIST3 )
    DO  I = 1, N	!  reorder according to INDX array
        SORTED1( I ) = LIST1( INDX( I ) )
        SORTED2( I ) = LIST2( INDX( I ) )
        SORTED3( I ) = LIST3( INDX( I ) )
        SDATA1( I )  = DATA1( INDX( I ) )
        SDATA2( I )  = DATA2( INDX( I ) )
        ...
    END DO
    ...
</PRE><P> 

<H2> C Usage </H2>

    Construct an index array ind[] to unsorted 2-key-tuple tables 
    list1[] and list2[], call qsorti2() and use its results to 
    generate the sorted 2-tuple tables sort1[] and sort2[]:
<PRE>
...
#define N ...
...
int  i, k, n ;
int  ind[ N ] ,
     list1[ N ], list2[ N ], 
     sort1[ N ], sort2[ N ] ;
...  
/*  get n and list1[i], list2[i], i=0, ..., n-1.  Then: */ 
for( i = 0; i &lt; n ; i++ )  ind[ i ] = i ;
qsorti2( n, ind, list1, list2 ) ;
for( i = 0; i &lt; n ; i++ )
    {
    k = ind[ i ] ;
    sort1[ i ] = list1[ k ] ;
    sort2[ i ] = list2[ k ] ;
    }
...
</PRE>


<HR> <!----------------------------------------------------------------->

<A HREF = "SMATVEC.html" >
Previous:  <STRONG>SMATVEC</STRONG>
</A><P> 

<A HREF = "STR2S.html" >
Next:  <STRONG>STR2S</STRONG>
</A><P> 

<A HREF = "FINDS.html"> 
SEE ALSO: <STRONG><CODE>FIND*</CODE> Binary Search Routines</STRONG> 
</A><P>

<A HREF = "LOCATS.html"> 
SEE ALSO: <STRONG><CODE>LOCAT*</CODE> Binary Search-and-Insert Routines</STRONG> 
</A><P>

<A HREF = "AA.html#utility"> 
Up: <STRONG>Utility Routines</STRONG> 
</A><P>

<A HREF = "AA.html"> 
To: <STRONG>Models-3/EDSS I/O API:   The Help Pages</STRONG> 
</A><P>

<!--#include virtual="/INCLUDES/footer.html" -->
    <PRE>
    $Id: SORTI.html 75 2018-01-12 15:48:16Z coats $
    </PRE>

</BODY>
</HTML>

