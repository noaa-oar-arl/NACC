
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- "$Id: BUFFERED.html 75 2018-01-12 15:48:16Z coats $" -->
<META NAME="MSSmartTagsPreventParsing" CONTENT="TRUE">
<TITLE>
REAL FILES, PARALLEL FILES,  AND &quot;VIRTUAL FILES&quot;
</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF"
      TOPMARGIN="15"
      MARGINHEIGHT="15"
      LEFTMARGIN="15"
      MARGINWIDTH="15">
<H1>
REAL FILES AND &quot;VIRTUAL FILES&quot;
</H1>

<H2>
<A NAME="contents">Contents</A>
</H2>
    <UL>
        <LI>  <A HREF="#intro">Introduction</A>
        <LI>  <A HREF="#pncf"><VAR>PnetCDF</VAR> Distributed-I/O Files</A>
        <LI>  <A HREF="#list">File-Set File Lists</A>
        <LI>  <A HREF="#vol">VOLATILE Real Files</A>
        <LI>  <A HREF="#snoop">SNOOP Mode File Handling</A>
        <LI>  <A HREF="#buf">BUFFERED Virtual Files</A>
        <LI>  <A HREF="#pvm">COUPLING-MODE Virtual Files</A>
        <LI>  <A HREF="#bin">Native-Binary Real Files</A>
    </UL>

<H2>
<A NAME="intro">Introduction</A>
</H2>

    <BLOCKQUOTE>

    The I/O&nbsp;API provides both real, disk-based files (which may be
    <A HREF = "#vol">&quot;volatile&quot;</A> or not, and are
    implemented on top of either netCDF, PnetCDF,  or a native-binary
    implementation) and &quot;virtual files&quot; that may be used to
    provide safe, structured exchange of data -- the latter of
    &quot;<A HREF = "DATATYPES.html#grdded">gridded</A>,&quot;
    &quot;<A HREF = "DATATYPES.html#bndary">boundary</A>,&quot; or
    &quot;<A HREF = "DATATYPES.html#custom">custom</A>&quot; types
    only -- between either cooperating programs or different modules in
    the same program.  You may even  safely interchange between using
    real files and virtual files in  different executions of the same
    program merely by changing the values of the logical names for the
    files at program launch (this would allow you to  look at the data
    being shared between modules whenever you want to, for example, at
    high temporal resolution).  There are two types of virtual files:
    memory-resident <A HREF="#buf">BUFFERED</A> virtual files that can
    be used to share data between modules of a single program; and
    PVM-mailbox based <A HREF="#pvm">COUPLING-MODE</A> virtual files
    that  can be used to share data and coordinate scheduling between
    different  programs, even if they are executing on different
    machines half a continent apart across the Internet.
    <P>

    </BLOCKQUOTE>

    <EM><A HREF="#contents">Back to <STRONG>Contents</STRONG></A></EM>
    <P>

<HR> <!----------------------------------------------------------------->

<H2>
<A NAME="pncf"><VAR>pnetCDF</VAR> Distributed-I/O Files</A>
</H2>

    <BLOCKQUOTE>

    I/O&nbsp;API Version&nbsp;3.2 introduces support for distributed
    parallel I/O using
    <A HREF="https://trac.mcs.anl.gov/projects/parallel-netcdf"><VAR>PnetCDF</VAR></A>
    from Argonne National Laboratory, for use in CMAQ-5.1 and later. The
    original concept and the prototype code are due to Dr.&nbsp;David
    Wong, US&nbsp;EPA.  This code has been extensively extended and
    revised, to meet the needs of proper I/O&nbsp;API integration and
    software engineering standards.
    <P>
    There are a number of restrictions:
    <UL>
        <LI> Only GRIDDED files are supported.
        <LI> All distributed-I/O files must be on the same grid
        (matching the CMAQ cross-point grid).
        <LI>There is one fixed data-distribution and processor-map,
        which is the same as the one specified by CMAQ.
    </UL>
    Additionally, the following environment variables are needed
    for setting up how the data is distributed over the processors:
    <BLOCKQUOTE>
    <DL>
        <DT><CODE>GRIDDESC</CODE></DT>
        <DD>Path name for the <A HREF="">GRIDDESC file</A></DD>
        <P>
        <DT><CODE>GRID_NAME</CODE></DT>
        <DD><CODE>GRIDDESC</CODE>-name for the data grid</DD>
        <P>
        <DT><CODE>NPCOL_NPROW</CODE></DT>
        <DD>Blank-delimited list with the column- and row-dimensions
        for the processor-grid<BR>
        <EM>Note that this list needs to be enclosed by quotes
        (either single or double).</EM></DD>
        <P>
    </DL>
    </BLOCKQUOTE>
    To declare that a particular file is to be used with PnetCDF
    parallel I/O, you need a <CODE>MPI:</CODE> prefix on the
    path-name in the usual <CODE>setenv</CODE> statement, as in
    the following example running on a 6&times;8 processor-grid
    (48 processors in all):
    <PRE>
    setenv  GRIDDESC     /nas01/depts/ie/cempd/WRFCMAQ/CMAQv5.0.1.GRIDDESC.txt
    setenv  GRID_NAME    US36_CRO
    setenv  NPCOL_NPROW  &quot;6 8&quot;
    ...
    setenv  CHEMCONC3D   MPI:/tmp/mydir/cmaq.conc.US36_CRO.2015233.ncf
    </PRE>
    <P>

    <STRONG>I/O&nbsp;API builds usiing PnetCDF are not link compatible
    with ordinary builds, and should be kept carefully separate from
    them.</STRONG><BR>
    You can build the I/O API to use PnetCDF/MPI distributed I/O using
    the following binary types (or use them as templates to build your
    own custom binary type):
    <BLOCKQUOTE><DL>
        <DT>Makeinclude.Linux2_x86_64gfortmpi
        <DT>Makeinclude.Linux2_x86_64ifortmpi
        <DT>Makeinclude.Linux2_x86_64pgmpi
        <DT>Makeinclude.Linux2_x86_64sunmpi
    </DL></BLOCKQUOTE>
    When performing the link-step to create model-executables,
    you will need to put the PnetCDF libraries in the library-build
    directory, and add the PnetCDF libraries to the link-step
    command line (assuming netCDF-4 style libraries below):
    <BLOCKQUOTE><CODE>
    ... -lpnetcdf -lnetcdff -lnetcdf ...
    </CODE></BLOCKQUOTE>
    <P>

    </BLOCKQUOTE>

    <EM><A HREF="#contents">Back to <STRONG>Contents</STRONG></A></EM>
    <P>

<HR> <!----------------------------------------------------------------->

<H2>
<A NAME="list">File-Set File Lists</A>
</H2>

    <BLOCKQUOTE>

    Multiple files which have the same structure (type, dimensions, list
    of variables, time step), and which cover an extended time period
    may be opened under a single logical name by:
    <PRE>
    setenv FILE_1 &lt;path name&gt;
    ...
    setenv FILE_N &lt;path name&gt;
    setenv ANAME  LIST:FILE_1,...,FILE_N
    </PRE>
    subject to the requirement that the value for <CODE>ANAME</CODE>
    has length at most 256 for I/O&nbsp;API 3.0 or earlier, and 65535
    for 3.1 or later.  In case of overlapping time step sequences,
    the rule is &quot;first file wins,&quot; i.e., if the data is
    available from the first file, <CODE>FILE_1</CODE>, use it; else if
    it is available from the second file, use that, and so on.
    <P>
    Because of this rule, if you have a sequence of overlapping files
    covering an extended time period, you probably want to put the list
    <CODE>LIST:FILE_1,...,FILE_N</CODE>  in reverse chronological order.
    For example, if the files <CODE>data.M-N.ncf</CODE> have data
    from 00Z on day M through 00Z on day N from consecutive model
    runs, then you would probably want to list them in reverse
    chronological order, at least if you want to get data
    for 2015124:000000 from file <CODE>data.2015124-2015125.ncf</CODE>:
    <PRE>
    setenv F123 /my/dir/data.2015123-2015124.ncf
    setenv F124 /my/dir/data.2015124-2015125.ncf
    setenv F125 /my/dir/data.2015125-2015126.ncf
    setenv F126 /my/dir/data.2015126-2015127.ncf
    setenv ANAME  LIST:F126,F125,F124,F123
    ...
    </PRE>
    <P>

    </BLOCKQUOTE>

    <EM><A HREF="#contents">Back to <STRONG>Contents</STRONG></A></EM>
    <P>

<HR> <!----------------------------------------------------------------->


<H2>
<A NAME="vol">VOLATILE Real Files</A>
</H2>

    <BLOCKQUOTE>

    Real (netCDF or native-binary disk-based) I/O&nbsp;API files may
    optionally be declared &quot;volatile&quot; by the addition of a
    trailing <CODE>&quot;&nbsp;-v&quot;</CODE> to the value of the
    file's <A HREF = "LOGICALS.html">logical name</A> in order to tell
    the I/O&nbsp;API to perform disk-synch operations before every
    input and after every output operation on that file:
    <PRE>
    ...
    setenv  QUX  &quot;/tmp/mydir/volatiledata.mymodel -v&quot;
    </PRE><P>
    <P>

    These file based lower layers attempt the I/O optimization of not
    writing a file's header&mdash;needed in order to interpret the file's
    contents&mdash;out to disk until either a &quot;synch&quot; operation
    is performed, or until the file is closed.  This has the effect of
    making non-volatile output files unreadable until the program that
    writes them does a  <A HREF="SYNC3.html"><CODE>SYNC3()</CODE></A> call for the
    individual files, or <A HREF="SHUT3.html"><CODE>SHUT3()</CODE></A> or
    <A HREF="M3EXIT.html"><CODE>M3EXIT()</CODE></A> (or making the files
    unreadable if the program crashes unexpectedly).
    This extra &quot;synch&quot; operation does cause some (usually
    small) performance penalty, but it allows other programs to read
    I/O&nbsp;API files while they are still being written, and prevents
    data loss upon program crashes.
    <P>

    </BLOCKQUOTE>

    <EM><A HREF="#contents">Back to <STRONG>Contents</STRONG></A></EM>
    <P>

<HR> <!----------------------------------------------------------------->


<H2>
<A NAME="snoop"><U><VAR>Snoop Mode</VAR></U>. File-Handling</A>
</H2>

    <BLOCKQUOTE>

    I/O&nbsp;API <U><VAR>Snoop Mode</VAR></U> capability may be
    activated by adding <CODE>-DIOAPI_SNOOP=1</CODE> to
    <CODE>DEFINEFLAGS</CODE> in the <VAR>ioapi/Makefile</VAR>.
    <P>
    Snoop Mode is designed to enable &quot;pipelining&quot; of data
    through multiple modeling/product-generation programs, e.g., for
    forecast-modeling systems. This allows the generation of early-hour
    products well before the entire forecast is complete; moreover,
    it will enable the operating system to make better use of its
    internal I/O-buffers, further increasing system modeling efficiency.
    <P>
    It is controlled by environment variables <CODE>SNOOPSECS3</CODE>
    and <CODE>SNOOPTRY3</CODE>.  When it is active (positive-integer
    values for these environment variables), when read-operations
    <CODE>READ3(), XTRACT3(), INTERP3(), and DDTVAR3()</CODE> encounter
    end-of-file, they  will re-try for up to  <CODE>SNOOPTRY3</CODE>
    attempts, with delay <CODE>SNOOPSECS3</CODE> seconds in between
    attempts.
    <P>
    If <CODE>SNOOPTRY3&nbsp;&lt;&nbsp;0</CODE> or
    <CODE>SNOOPSECS3&nbsp;&le;&nbsp;0</CODE>, then <VAR>Snoop Mode</VAR>
    is turned off.
    <P>
    If <CODE>SNOOPTRY3&nbsp;=&nbsp;0</CODE> then the number of
    re-tries is (almost) unlimited.
    <P>

    </BLOCKQUOTE>

    <EM><A HREF="#contents">Back to <STRONG>Contents</STRONG></A></EM>
    <P>

<HR> <!----------------------------------------------------------------->

<H2>
<A NAME="buf">BUFFERED Virtual Files</A>
</H2>

    <BLOCKQUOTE>

    For memory-resident BUFFERED files, one restriction at present is
    that  the <A HREF = "DATATYPES.html#basic"> basic data type </A> of
    all  variables in the virtual file be either integer or real. The
    other restriction is that only two time steps of data are kept in
    the buffered file -- the &quot;even step&quot; and the  &quot;odd
    step&quot; (which in normal usage are the last two time  steps
    written).  Otherwise, you write code to open, read, write, or
    interpolate data just as you would with a &quot;real&quot; file.
    This provides for structured name based <EM>identity-tagged</EM>
    exchange of data between  different modules in the same program --
    since data are stored and  accessed by file-name, variable-name,
    date, and time, the system will detect at run-time the attempt to
    request data not yet initialized (unlike the situation where data
    is exchanged via Fortran  <CODE>COMMON</CODE>s  - we've detected
    some obscure use-before-calculate bugs by replacing
    <CODE>COMMON</CODE>s with BUFFERED virtual files.)

    <P>

    To set up a buffered virtual file, <VAR>setenv</VAR> the value of
    the file's <A HREF = "LOGICALS.html"> logical name </A> to the
    value  <CODE>BUFFERED</CODE> (instead of to the pathname of a real
    physical  file), as given below:
<PRE>
    ...
    #
    # myprogram uses &quot;qux&quot; for internal data sharing:
    #
    setenv qux BUFFERED
    ...
    /user/mydir/myprogram
    ...
</PRE>
<P>

     <STRONG>Restrictions:</STRONG>
     <OL>
         <LI>  For all-variable <VAR>READ3()</VAR>
               and <VAR>WRITE3()</VAR> calls, all of the variables in
               the file must be of <A HREF = "DATATYPES.html#basic">
               type <CODE>M3REAL</CODE></A>.
         <LI>  Prior to the I/O&nbsp;API V&nbsp;2.2-beta-May-3-2002
               release, all variables in buffered virtual files must
               be of <A HREF = "DATATYPES.html#basic"> type
               <CODE>M3REAL</CODE></A>.
     </OL>

    </BLOCKQUOTE>

    <P>
    <EM><A HREF="#contents">Back to <STRONG>Contents</STRONG></A></EM>
    <P>

<HR> <!----------------------------------------------------------------->

<H2>
<A NAME="pvm">COUPLING-MODE Virtual Files</A>
</H2>

    <BLOCKQUOTE>

    As part of the MCNC
    <A HREF = "http://terra.baronams.com:/projects/ppar/index.html">Practical
    Parallel Project</A>, MCNC developed an extended
    <STRONG>Model Coupling Mode</STRONG> for the I/O&nbsp;API.
    This mode, implemented using
    <A HREF = "http://www.epm.ornl.gov:80/pvm/">PVM&nbsp;3.4</A>
    mailboxes, allows the user to specify in
    the run-script whether &quot;file&quot; means a physical file on
    disk or a PVM mailbox-based communications channel (a
    <STRONG>virtual file</STRONG>), on the basis of the value of the
    file's <A HREF = "ENVIRONMENT.html">logical name</A>:
    <PRE><STRONG>
    setenv FOO                &quot;virtual BAR&quot;
    setenv IOAPI_KEEP_NSTEPS  3
    </STRONG></PRE>
    declares that <CODE>FOO</CODE> is the logical name of a virtual
    file whose physical name (in terms of PVM mailbox names) is
    <CODE>BAR</CODE>.  The additional environment variable
    <CODE>IOAPI_KEEP_NSTEPS</CODE> determines the number of time
    steps to keep in PVM mailbox buffers -- if it is 3 (as here), and
    there are already 3 timesteps of variable <CODE>QUX</CODE> in the
    mailboxes for virtual file <CODE>FOO</CODE>, then writing a fourth
    time step of <CODE>QUX</CODE> to <CODE>FOO</CODE> causes the earliest
    time step of <CODE>QUX</CODE> to be erased, leaving only timesteps 2,
    3, and&nbsp;4.  This is necessary, so that the coupled modeling system
    does not require an infinite amount of memory for its sustained
    operation.  If not set, <CODE>IOAPI_KEEP_NSTEPS</CODE> defaults
    to&nbsp;2 (the minimum needed to support <CODE>INTERP3()</CODE>'s
    double-buffering).
    <P>

    The (UNIX) environments in which the modeler launches multiple models
    each of which reads or writes from a virtual file must all agree
    on its physical name (usually achieved by sourcing some script that
    contains the relevant <VAR>setenv</VAR> commands).
    <P>

    For models exchanging data via virtual files of the I/O&nbsp;API's
    coupling mode, the I/O&nbsp;API schedules the various processes on
    the basis of data availability:
    <UL>
        <LI>  The modeler must start up a PVM session that will
              &quot;contain&quot; all the virtual files and enroll in
              it all those machines which will be running the various
              modeling programs before starting up the various models
              in a coupled modeling system on those respective machines.
              <P>
        <LI>  <CODE>OPEN3()</CODE> calls for read-access to virtual
              files that haven't yet been opened for write access by
              some other process put the caller to sleep until the
              file is opened; and
              <P>
         <LI>  <CODE>READ3()</CODE>, <CODE>INTERP3()</CODE>, or
              <CODE>DDTVAR3()</CODE> calls for virtual-file data which
              has not yet been written put the reading process to sleep
              until the data arrives, at which point the reader is
              awakened and given the data it requested.
    </UL>
    There are two requirements on the modeler:
    <UL>
        <LI>  structuring reads and writes so as to avoid deadlocks
              (two or more models, each asleep while waiting for input
              from the other); and
              <P>
        <LI>  providing enough feedbacks to prevent one process from
              &quot;racing ahead&quot; of the others.  In a one-way
              coupled system, this may mean the introduction of
              artificial <VAR>synchronization files</VAR> which exist
              solely to provide these feedbacks.
    </UL>
    Using coupling mode to construct complex modeling systems has several
    advantages from the model-engineering point of view:
    <UL>
        <LI>  Since data is tagged by variable-name, simulation date,
              and time, the system is not subject to data scrambling
              because of implicit programming assumptions about the
              data ordering, in the way that stream-like communications
              channels are.
              <P>
        <LI>  The same programs work unchanged both in standalone mode
              (reading input from files and writing output to files)
              and in coupled-model mode (reading and writing selected
              inputs or outputs to/from PVM mailboxes).
              <P>
        <LI>  Readers and writers do not need to know about each other
              in detail.  In particular, any reader only needs to know
              that <EM>some</EM> writer will put the variables it needs
              into the mailbox.  Writers don't care whether readers
              even exist or not.  It is easy to change system configuration
              by just adding additional processes or by deleting processes
              and replacing them by appropriate disk-based files containing
              the data that would have been produced.  In MCNC's Real-Time
              Ozone Forecast System, for example, the set of programs that
              runs to compute each day's ozone forecast varies from day to
              day, on the basis of such things as whether particular data
              ingest feeds have succeeded or failed over the past two days.
              <P>
        <LI>  One writer can supply multiple readers without special
              programming (and without needing to know who they are).
              For example, in a coupled system with the
              MM5/<A HREF="MCPL.html">MCPL</A>
              meteorology model, the SMOKE emissions model, and the
              MAQSIP air quality model, MM5 produces 5 time-stepped
              output &quot;virtual files&quot;, some variables of two
              of which are read by SMOKE and all of which are read by
              MAQSIP; and SMOKE produces one output &quot;virtual
              files&quot; read by MAQSIP.  SMOKE is itself a system
              of five programs coupled together by virtual files and
              fed by a number of additional disk-files produced
              off-line.  MAQSIP produces a &quot;synchronization file&quot;
              read by MM5/MCIP and used to keep MM5/MCIP from running ahead
              and exhausting all memory available for mailbox-buffer space.
              <P>
    </UL>
    <P>

    </BLOCKQUOTE>

    <EM><A HREF="#contents">Back to <STRONG>Contents</STRONG></A></EM>
    <P>

<HR> <!----------------------------------------------------------------->

<H2>
<A NAME="bin">Native-Binary Real Files</A>
</H2>

    <H3>Abstract:  Use</H3>

    <BLOCKQUOTE>
    <EM><U>NOTE:</U>  These are primarily for use at NCEP, where
    the office politics forbids the presence of netCDF on their
    computers.</EM>
    <P>

    The following environment-variable assignment tells the I/O&nbsp;API
    that the indicated file is in the I/O&nbsp;API version of native
    binary representation, rather than netCDF or PVM-mailbox virtual:
    <BLOCKQUOTE>
    <CODE>setenv&nbsp;&nbsp;&lt;logical&nbsp;&nbsp;name&gt;&nbsp;&nbsp;BIN:&lt;path&nbsp;&nbsp;name&gt;</CODE>
    </BLOCKQUOTE>
    Note that this assignment is on a file-by-file basis, so that a
    program may use several different I/O&nbsp;API files with different
    modes for different purposes.  As a special case, this allows
    ordinary &quot;I/O&nbsp;API M3TOOLS&quot; programs such as
    <A HREF="M3CPLE.html">M3CPLE</A> to serve as translators back and
    forth between I/O&nbsp;API native binary and I/O&nbsp;API netCDF.
    <P>

    </BLOCKQUOTE>

    <H3>Introduction</H3>

    <BLOCKQUOTE>

    This section describes the structure of the files for a new underlying
    <STRONG>(&quot;<CODE>BINFIL3</CODE>&quot;) binary mode</STRONG> for
    the <A HREF= "index.html">EDSS/Models-3 I/O&nbsp;API</A>, to
    supplement the existing (and default) <STRONG>netCDF-file
    mode</STRONG>, the in-memory <STRONG>BUFFERED</STRONG> mode, and
    the PVM-based <STRONG>virtual mode</STRONG>.
    <P>
    Since this mode uses native machine binary representation for its
    data as its underlying data representation layer, it should offer
    somewhat greater performance than the machine independent lower
    layers (<CODE>netCDF</CODE>, <CODE>PVM</CODE>) do, for applications
    where I/O performance is critical.  On the other hand, it is very
    desirable to keep the header metadata in a portable format, so that
    user-level programs can still read the data on binary-incompatible
    platforms and perform the appropriate data conversion themselves.
    For this reason, header metadata is stored in the portable formats,
    as described below.
    <P>

    The sequence of data structures in these files is modeled somewhat
    after the structure of netCDF files, although the implementation
    mechanisms to store some of the metadata in a machine independent
    fashion are to some extent borrowed from ideas found in other
    formats, e.g., GRIB.
    <P>

    </BLOCKQUOTE>

    <H3>Implementation Considerations:  Restrictions and Limitations</H3>

    <BLOCKQUOTE>

    <UL>
        <LI>  Initially, the <STRONG>supported platforms</STRONG> are
              ones with UNIXoid Fortrans (as listed below), but not
              Win32 nor Cray.  Of these latter, Cray is the more
              difficult (made more difficult by the fact that I don't
              have access to one of their systems any more...)
              <UL>
                  <LI> OSF/Alpha from DEC^H^H^HCompaq^H^H^H^H^H^H HP
                  <LI> HP/UX
                  <LI> IBM AIX
                  <LI> Sun
                  <LI> SGI
                  <LI> Linux
                       <UL>
                            <LI> x86 with <VAR>gcc/g77</VAR>,
                                 <VAR>gcc/g95</VAR>,
                                 <VAR>gcc/lf95</VAR>,
                                 <VAR>pgcc/pgf90</VAR>,
                                 <VAR>gcc/pgf90</VAR>, or
                                 <VAR>icc/ifc</VAR>;
                            <LI> x86_64 with <VAR>gcc/g77</VAR>,
                                 <VAR>gcc/g95</VAR>, or
                                 <VAR>pathcc/pathf90</VAR>;
                            <LI> Alpha with <VAR>gcc/g77</VAR> or
                                 <VAR>cc/fort</VAR>;
                            <LI> ia64 with <VAR>gcc/g77</VAR>,
                                 <VAR>gcc/g95</VAR>, or
                                 <VAR>icc/ifort</VAR>;
                            <LI> [PPC970 with either <VAR>gcc/g77</VAR>,
                                 <VAR>gcc</VAR> andAbsoft
                                 <VAR>f90</VAR>, or IBM
                                 <VAR>xlc/xlf</VAR> should not be
                                 difficult but hasn't been done yet]
                       </UL>
                  <LI> [Mac OS-X with either <VAR>gcc/g77</VAR> or
                       <VAR>xlc/xlf</VAR> should not be difficult but
                       hasn't been done yet either, AFAIK]
              </UL>
              <P>

        <LI>  Initially, the <STRONG>supported data types</STRONG> are
              those needed for current air quality modeling (and excluding
              the grid-nest and stream-hydrology data types):
              <UL>
                  <LI> <STRONG><CODE>CUSTOM3</CODE></STRONG>
                  <LI> <STRONG><CODE>GRDDED3</CODE></STRONG>
                  <LI> <STRONG><CODE>BNDARY3</CODE></STRONG>
                  <LI> <STRONG><CODE>IDDATA3</CODE></STRONG>
                  <LI> <STRONG><CODE>PROFIL3</CODE></STRONG>
                  <LI> <STRONG><CODE>SMATRX3</CODE></STRONG>
              </UL>
              <P>

         <LI> Initially, the following (as far as I know, unused)
              two I/O routines are <STRONG>not&nbsp;supported</STRONG>:
              <UL>
                  <LI> <STRONG><CODE>READ4D</CODE></STRONG>
                  <LI> <STRONG><CODE>WRITE4D</CODE></STRONG>
              </UL>
              <P>

   </UL>

    </BLOCKQUOTE>

   <H3>Implementation Strategy</H3>

    <BLOCKQUOTE>

    <UL>
       <LI>  Implementation is in C, interfacing to Fortran in the same
             manner as the rest of the I/O&nbsp;API C code.
             <P>
       <LI>  Uses C <CODE><STRONG>stdio</STRONG></CODE>, and particularly
             uses <CODE><STRONG>fseeko()</STRONG></CODE> for seeks
             (instead of <CODE><STRONG>fseek()</STRONG></CODE>), in
             order to interoperate with large file systems (implies
             Linux <CODE>glibc</CODE> version &gt; 2.0).
             <P>
       <LI>  Implementation is in file
             <CODE><STRONG>iobin3.c</STRONG></CODE>.
             <P>
       <LI>  <CODE><STRONG>INIT3</STRONG></CODE> calls
             <CODE><STRONG>INITBIN3</STRONG></CODE>
             <P>
       <LI>  <CODE><STRONG>FLUSH3</STRONG></CODE> calls and other
             required disk synchronizations use new routine
             <CODE><STRONG>SYNCFID</STRONG></CODE> that unifies calls
             to <CODE><STRONG>FLUSHBIN3</STRONG></CODE> and
             <CODE><STRONG>NF_SYNC</STRONG></CODE>
             <P>
       <LI>  For <CODE><STRONG>BINFIL3</STRONG></CODE> files,
             <UL>
                 <LI> <CODE><STRONG>CRTFIL3</STRONG></CODE> calls
                      <CODE><STRONG>CRTBIN3</STRONG></CODE>
                 <LI> <CODE><STRONG>OPNFIL3</STRONG></CODE> calls
                      <CODE><STRONG>OPNBIN3</STRONG></CODE>
                 <LI> <CODE><STRONG>RDTFLAG</STRONG></CODE> calls
                      <CODE><STRONG>RDBFLAG</STRONG></CODE>
                 <LI> <CODE><STRONG>WRTFLAG</STRONG></CODE> calls
                      <CODE><STRONG>WRBFLAG</STRONG></CODE>
                 <LI> <CODE><STRONG>RDVARS</STRONG></CODE> calls
                      <CODE><STRONG>RDBVARS</STRONG></CODE>
                 <LI> <CODE><STRONG>WRVARS</STRONG></CODE> calls
                      <CODE><STRONG>WRBVARS</STRONG></CODE>
                 <LI> <CODE><STRONG>XTRACT3</STRONG></CODE> calls
                      <CODE><STRONG>XTRBIN3</STRONG></CODE>
                 <LI> <CODE><STRONG>CLOSE3</STRONG></CODE> calls
                      <CODE><STRONG>CLOSEBIN3</STRONG></CODE>
             </UL>
             <P>
       <LI>  <CODE><STRONG>OPNLOG3</STRONG></CODE> (called from
             <CODE><STRONG>OPEN3</STRONG></CODE>) now logs the
             implementation-layer used
             <P>
       <LI>  <CODE><STRONG>SHUT3</STRONG></CODE> does a sequence of
             <CODE><STRONG>CLOSEBIN3</STRONG></CODE> calls
             <P>
    </UL>

    </BLOCKQUOTE>

    <P>

    <H3>Metadata Format</H3>

    <BLOCKQUOTE>

    The following representations of primitive data types of
    significance to the I/O&nbsp;API are used to store metadata in a
    portable fashion (so that the metadata can be interpreted on
    platforms other than the originating platform) in I/O&nbsp;API
    <STRONG><CODE>BINFIL3</CODE></STRONG> files.  In principle, this
    lets the application programmer use the
    <STRONG><CODE>BINFIL3</CODE></STRONG> layer of the I/O&nbsp;API to
    read the data on any platform, determine the transformations
    necessary to interpret it on his platform, and then perform the
    transformations on the data and use it.
    <P>
    <BLOCKQUOTE>
    <DL>
        <DT> <STRONG><CODE>INT4</CODE></STRONG>
        <DD> represented by a 4-byte string, in little-Endian order:
             <BLOCKQUOTE>
                 <STRONG><CODE>BYTE_0(X)</CODE></STRONG> contains
                 <CODE>(unsigned&nbsp;char)(X&amp;&amp;255)</CODE>,
                 i.e.,  the least significant byte of X<BR>
                 <STRONG><CODE>BYTE_1(X)</CODE></STRONG> contains
                 <CODE>(unsigned&nbsp;char)((X/256)&amp;&amp;255)</CODE><BR>
                 <STRONG><CODE>BYTE_2(X)</CODE></STRONG> contains
                 <CODE>(unsigned&nbsp;char)((X/65536)&amp;&amp;255)</CODE><BR>
                 <STRONG><CODE>BYTE_3(X)</CODE></STRONG> contains
                 <CODE>(unsigned&nbsp;char)((X/16777216)&amp;&amp;255)</CODE><BR>
             </BLOCKQUOTE>
        <DT> <STRONG><CODE>REAL</CODE></STRONG>
        <DD> represented by a character string formatted with format
             equivalent to the Fortran
             <CODE>FORMAT&nbsp;<STRONG>1PE15.9</STRONG></CODE>,
             followed by a trailing ASCII NULL
             <P>
        <DT> <STRONG><CODE>DOUBLE</CODE></STRONG>
        <DD> represented by a character string formatted as
             <STRONG><CODE>1PD27.19</CODE></STRONG>, followed by a
             trailing ASCII NULL
             <P>
        <DT> <STRONG><CODE>NAME</CODE></STRONG>
        <DD> Equivalent to a Fortran <STRONG><CODE>CHARACTER*16</CODE></STRONG> type
             (fixed-length 16-byte string, padded on the right by
             blanks; <EM>not nul-terminated as a C string would be.</EM>)
             <P>
        <DT> <STRONG><CODE>LINE</CODE></STRONG>
        <DD> Equivalent to a Fortran <STRONG><CODE>CHARACTER*80</CODE></STRONG> type
             (fixed-length 80-byte string, padded on the right by
             blanks)
             <P>
        <DT> <STRONG><CODE>STRING</CODE></STRONG>
        <DD> Equivalent to the Mac Fortran internal representation of
             a Fortran <STRONG><CODE>CHARACTER*(*)</CODE></STRONG>
             variable (with blank-padding on the right), i.e., as
             a C &quot;struct hack&quot;
                 <TT><BLOCKQUOTE>
                 struct{<BR>
                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INT4&nbsp;length;<BR>
                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;contents[&nbsp;length&nbsp;];<BR>
                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;;<BR>
                 </BLOCKQUOTE></TT>
    </DL>
    </BLOCKQUOTE>
    <P>
    </BLOCKQUOTE>

    <H3>File Data Structure Design</H3>

    <BLOCKQUOTE>

    The structure of a <CODE>BINFIL3</CODE> file is as follows:
    <P>
    <TT>
    <BLOCKQUOTE>
    <U><STRONG>Header Section</STRONG></U>
    <BLOCKQUOTE>
        INT4 <STRONG>IOAPI_VRSN</STRONG>:  I/O&nbsp;API Version
        <P>
        <U><STRONG>Machine/Compiler Architecture Metadata</STRONG></U>
        <BLOCKQUOTE>
             INT4 <STRONG>BYTE_ORDER</STRONG>: Byte order, i.e., the C
             subscripts at which BYTE_0, BYTE_1, BYTE_2, BYTE_3 would
             occur if we think of an integer as a C union:
             <BLOCKQUOTE><STRONG>
             union{ int idata; char cdata[4] } ;
             </STRONG></BLOCKQUOTE>
             <P>
             INT4 <STRONG>INTSIZE</STRONG>: size of Fortran
             &quot;INTEGER&quot;
             <P>
             INT4 <STRONG>REALSIZE</STRONG>: size of Fortran
             &quot;REAL&quot;
             <P>
             INT4 <STRONG>DBLESIZE</STRONG>: size of Fortran
             &quot;DOUBLE&nbsp;PRECISION&quot;
             <P>
        </BLOCKQUOTE>
        <P>
        <U><STRONG>Per-File Metadata</STRONG></U>
        <BLOCKQUOTE>
             NAME <STRONG>GRIDNAME</STRONG>: grid name
             <P>
             NAME <STRONG>UPDATE_NAME</STRONG>: name of the last program
             writing to file
             <P>
             LINE <STRONG>EXECUTION</STRONG>: value of environment
             variable EXECUTION_ID
             <P>
             LINE <STRONG>FILE_DESC[ MXDESC3=60 ]</STRONG>: array
             containing file
             description (set by programmer during OPEN3())
             <P>
             LINE <STRONG>UPDATE_DESC[ MXDESC3=60 ]</STRONG>: array
             containing run description, from file with logical name
             SCENFILE
             <P>
        </BLOCKQUOTE>
        <P>
        <U><STRONG>Dimension/Type Metadata</STRONG></U>
        <BLOCKQUOTE>
             INT4 <STRONG>FTYPE</STRONG>: File data type
             <BLOCKQUOTE>
                 CUSTOM3, GRDDED3, BNDARY3, IDDATA3, PROFIL3,
                 or SMATRX3
             </BLOCKQUOTE>
             <P>
             INT4 <STRONG>GDTYP</STRONG>:  map projection type
             <BLOCKQUOTE>
                  LATGRD3=1 (Lat-Lon),
                  <BR>
                  LAMGRD3=2 (Lambert conformal
                  conic),
                  <BR>
                  MERGRD3=3 (general tangent Mercator),
                  <BR>
                  STEGRD3=4 (general tangent stereographic),
                  <BR>
                  UTMGRD3=5 (UTM, a special case of Mercator),
                  <BR>
                  POLGRD3=6 (polar secant stereographic),
                  <BR>
                  EQMGRD3=7 (equatorial secant Mercator), or
                  <BR>
                  TRMGRD3=8 (transverse secant Mercator)
                  <BR>
             </BLOCKQUOTE>
             <P>
             INT4 <STRONG>VGTYP</STRONG>:  vertical coordinate type
             <BLOCKQUOTE>
                  VGSGPH3=1 (hydrostatic sigma-P),
                  <BR>
                  VGSGPN3=2 (nonhydrostatic sigma-P),
                  <BR>
                  VGSIGZ3=3 (sigma-Z),
                  <BR>
                  VGPRES3=4 (pressure (mb)),
                  <BR>
                  VGZVAL3=5 (Z (m above sea lvl), or
                  <BR>
                  VGHVAL3=6 (H (m above ground))
             </BLOCKQUOTE>
             INT4 <STRONG>NCOLS</STRONG>: number of grid columns
             <P>
             INT4 <STRONG>NROWS</STRONG>: number of grid rows
             <P>
             INT4 <STRONG>NLAYS</STRONG>: number of layers
             <P>
             INT4 <STRONG>NTHIK</STRONG>:
             <BLOCKQUOTE>
                 for BNDARY3 files, perimeter thickness
                 (cells), or for SMATRX3 files, number of matrix-columns
                 (unused for other file types)
             </BLOCKQUOTE>
        </BLOCKQUOTE>
        <P>
        <U><STRONG>Temporal Metadata</STRONG></U>
        <BLOCKQUOTE>
             INT4 <STRONG>SDATE</STRONG>:  starting date, coded YYYYDDD
             according to Models-3 conventions
             <P>
             INT4 <STRONG>STIME</STRONG>:  starting time, coded HHMMSS
             according to Models-3 conventions
             <P>
             INT4 <STRONG>TSTEP</STRONG>:  time step, coded HHMMSS
             according to Models-3 conventions
             <P>
             INT4 <STRONG>NRECS</STRONG>: current number of time step
             records in the file (1-based Fortran-style counting)
             <P>
        </BLOCKQUOTE>
        <P>
        <U><STRONG>Spatial Metadata</STRONG></U>
        <BLOCKQUOTE>
             DOUBLE <STRONG>P_ALPHA</STRONG>:  first map projection
             descriptive parameter
             <P>
             DOUBLE <STRONG>P_BETA</STRONG>:  second map projection
             descriptive parameter
             <P>
             DOUBLE <STRONG>P_GAMMA</STRONG>:  third map projection
             descriptive parameter
             <P>
             DOUBLE <STRONG>X_CENTER</STRONG>:  Longitude of the
             Cartesian map projection coordinate-origin (location
             where X=Y=0)
             <P>
             DOUBLE <STRONG>Y_CENTER</STRONG>:  Latitude of the
             Cartesian map projection coordinate origin (map units)
             <P>
             DOUBLE <STRONG>X_ORIGIN</STRONG>: Cartesian X-coordinate of
             the lower left corner of the (1,1) grid cell (map units)
             <P>
             DOUBLE <STRONG>Y_ORIGIN</STRONG>: Cartesian Y-coordinate of
             the lower left corner of the (1,1) grid cell (map units)
             <P>
             DOUBLE <STRONG>X_CELLSIZE</STRONG>: X-coordinate cell
             dimension (map units)
             <P>
             DOUBLE <STRONG>Y_CELLSIZE</STRONG>: Y-coordinate cell
             dimension (map units)
             <P>
             REAL <STRONG>VGTOP</STRONG>: model-top, for sigma
             vertical-coordinate types
             <P>
             REAL <STRONG>VGLEVELS[0:NLAYS+1]</STRONG>: array of
             vertical coordinate level values; level 1 of the grid goes
             from vertical coordinate VGLEVELS[0] to VGLEVELS[1], etc.
             <P>
        </BLOCKQUOTE>
        <P>
        <U><STRONG>Per-Variable Metadata</STRONG></U>
        <BLOCKQUOTE>
             NAME <STRONG>VNAME[ NVARS ]</STRONG>: array of  variable names
             <P>
             NAME <STRONG>UNITS[ NVARS ]</STRONG>: array of units or 'none'
             <P>
             LINE <STRONG>VDESC[ NVARS ]</STRONG>: array of  array of variable descriptions
             <P>
             INT4 <STRONG>VTYPE[ NVARS ]</STRONG>: array of variable types:
             <BLOCKQUOTE>
                 M3BYTE = 1
                 <BR>
                 M3INT  = 4
                 <BR>
                 M3REAL = 5
                 <BR>
                 M3DBLE = 6
             </BLOCKQUOTE>
        </BLOCKQUOTE>
        <P>
        <U><STRONG>Additional attributes</STRONG></U>
        <BLOCKQUOTE>
            <U>Not implemented at this time.</U>
            <P>
            Eventually:  TBD, as necessary for the WRF extensions
            placed in I/O&nbsp;API Version&nbsp;2.2.  At this point,
            we anticipate that the implementation will be in terms of a
            sequence of &lt;name-type-value&gt; triplets
        </BLOCKQUOTE>
    </BLOCKQUOTE>
    <P>
    <U><STRONG>Data Section</STRONG></U>
    <BLOCKQUOTE>
        <U><STRONG>sequence of time step records</STRONG></U>
        <P>
        <BLOCKQUOTE>
            <STRONG><U>Time Step Header</U></STRONG>
            <P>
            <BLOCKQUOTE>
                INT4 <STRONG>FLAGS[2,NVARS]</STRONG>: array of
                data-availability flags (with Fortran-style left-major,
                1-based subscripting):
                <BLOCKQUOTE>
                    FLAGS[1,V] are the <U>dates</U> for the data
                    record, encoded YYYYDDD
                    <P>
                    FLAGS[2,V] are the <U>times</U> for the data
                    record, encoded HHMMSS
                    <P>
                    FLAGS[1,V] and FLAGS[2,V] are in consecutive
                    memory/disk locations.
                    <P>
                    (NOTE:  This amount of data is not functionally
                    necessary; however, it is included for the
                    historical reasons involving the convenience of
                    visualization-system programmers.)<P>
                </BLOCKQUOTE>
            </BLOCKQUOTE>
            <P>
            <STRONG><U>Time step Contents</U></STRONG>:
            <BLOCKQUOTE>
               <STRONG><U>array of data records</U></STRONG>,
               subscripted by variable 1,&nbsp;...,&nbsp;NVARS:
               <P>
               <BLOCKQUOTE>
                   <STRONG>&lt;type&gt; array of data</STRONG> for this
                   variable and time step.  Data is in native machine
                   binary format.
               </BLOCKQUOTE>
            </BLOCKQUOTE>
        </BLOCKQUOTE>
    </BLOCKQUOTE>
    </BLOCKQUOTE>
    </TT>

    </BLOCKQUOTE>

    <P>
    <EM><A HREF="#contents">Back to <STRONG>Contents</STRONG></A></EM>
    <P>

<HR> <!----------------------------------------------------------------->

<A HREF = "VBLE.html">
Previous Section:  <STRONG>Variables and Layers and Time Steps</STRONG>
</A><P>

<A HREF = "AA.html#conventions">
Up: <STRONG>Conventions</STRONG>
</A><P>

<A HREF = "AA.html">
To: <STRONG>Models-3/EDSS I/O API:   The Help Pages</STRONG>
</A><P>

</BODY>
</HTML>

