
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- "$Id: TUTORIAL.html 75 2018-01-12 15:48:16Z coats $" -->
<META NAME="MSSmartTagsPreventParsing" CONTENT="TRUE">
<TITLE> TUTORIAL:  Using the I/O&nbsp;API </TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF"
      TOPMARGIN="15"
      MARGINHEIGHT="15"
      LEFTMARGIN="15"
      MARGINWIDTH="15">

<!--#include virtual="/INCLUDES/header.html" -->

<H1>    TUTORIAL:  Using the I/O&nbsp;API </H1>


<H2> Introduction </H2>

<BLOCKQUOTE>
    The Models-3/EDSS <STRONG> I/O&nbsp;API </STRONG> is intended to provide
    an easy-to-learn, easy-to-use interface to data files for the model
    and model-related-tool developer.  There are only a few topics you'll
    need to know about:
    <BLOCKQUOTE>
    <DL>
        <DT> <A HREF = "#files">Files, Logical Names and Physical Names</A>

        <DT> <A HREF = "#descriptions">File descriptions, and
             types of data supported</A>

        <DT> <A HREF = "#start">How to start up and shut down the I/O&nbsp;API</A>

        <DT> <A HREF = "#open">How to open or create files</A>

        <DT> <A HREF = "#read">How to read data from files</A>

        <DT> <A HREF = "#write">How to write data to files</A>

        <DT> <A HREF = "#datetime"> Date and Time Conventions</A>

        <DT> <A HREF = "#typical"> outline for a typical modeling program</A>

        <DT> <A HREF = "#datetime"> Date and Time Conventions</A>
        <P>

        <DT> <A HREF = "AA.html"> I/O&nbsp;API Programmers Manual</A>
    </DL>
    </BLOCKQUOTE>
</BLOCKQUOTE>

<HR>

<H2> Abstract </H2>

<BLOCKQUOTE>
The Models-3 Input/Output Applications Programming Interface (I/O&nbsp;API)
is a selective and direct-access <STRONG>programming interface
to the data</STRONG>: you tell the system what variables and dates and times
you're talking about and it figures all the stuff about record numbers,
etc., for itself.  Also, you don't have to read the data in consecutive
order, or to write it in order, either -- you just ask for what you
want, and the I/O&nbsp;API finds it for you (although there are moderate
performance penalties for writing data out-of-order).  The files are
self-describing files -- that is, the file headers have all the
dimensioning and descriptive information needed about the data in them.
<P>

There is an underlying <STRONG>object model</STRONG> for environmental
data (especially atmospheric data) and the models that use
it&nbsp;&mdash; see the <A HREF="REQUIREMENTS.html">Requirements
Document</A> for more detail.  In general, if you're wondering about how
to manipulate the underlying objects according to the I/O&nbsp;API
conventions, <EM>there is probably an I/O&nbsp;API routine or
<A HREF = "#tools"><VAR>m3tools</VAR>. program</A> already
written to do it for you.</EM>
<BR>
On the other hand, a number of people have attempted to &quot;get
around&quot; the API and treat it as a &quot;data format&quot;, reading
or writing its data directly with their programs (e.g., <VAR>PAVE</VAR>
and <VAR>VERDI</VAR>). <STRONG>So far, every one of these attempts has
screwed up to one degree or another.</STRONG>
<P>


There are versions of the I/O&nbsp;API callable from both
<A HREF = "FORTRAN.html">Fortran</A> and from
<A HREF = "C.html">C</A>.  This document describes the Fortran
interface; the C interface is very  similar.  The major difference
between the two are that Fortran LOGICAL  functions returning .TRUE. or
.FALSE. correspond to C functions returning  1 or 0, Fortran
<CODE>&quot;.EXT&quot;</CODE>  <A HREF = "INCLUDE.html">include-files</A>
correspond one-to-one to  C <CODE>&quot;.h&quot;</CODE> include
files, and the C calls  look much like the Fortran calls, except that
file descriptions are  passed via pointers to data structures typedeffed
in <VAR>fdesc3.h</VAR>  instead of a <CODE>COMMON</CODE> found in
<CODE>FDESC3.EXT</CODE>
<P>

There are <STRONG>9 fundamental I/O routines</STRONG> you'll need to
know; these are described in more detail in later sections of the
documentation.  (In all, there are about 200 Fortran and 60 C routines,
many of which are &quot;private&quot; routines used internally.
See the <A HREF = "AA.html"> I/O&nbsp;API Programmers Manual</A>.)
<P>
<BLOCKQUOTE>
<DL>
    <DT><A HREF = "#start"><STRONG><CODE>INIT3()</CODE></STRONG></A> to
        start up (returning the Fortran unit number for the log file;
        it may be called repeatedly, and is a &quot;no-op&quot; for
        such repeated calls);
    <DT><A HREF = "M3EXIT.html"><STRONG><CODE>M3EXIT()</CODE></STRONG></A>,
        to shut programs down properly; it flushes all files, generates
        exit messages to the <A HREF = "ENVIRONMENT.html">program log</A>
        and then terminates the program with a user-supplied exit status
        (which should be 0  for success and nonzero for failure).
    <DT><A HREF = "#open"><STRONG><CODE>OPEN3()</CODE></STRONG></A> to open files;
    <DT><A HREF = "#desc"><STRONG><CODE>DESC3()</CODE></STRONG></A> to get file descriptions;
    <DT><A HREF = "#read"><STRONG><CODE>READ3()</CODE></STRONG>,
        <STRONG><CODE>INTERP3()</CODE></STRONG>,
        <STRONG><CODE>XTRACT3()</CODE></STRONG>, and
        <STRONG><CODE>DDTVAR3()</CODE></STRONG></A> to read,
        read-and-time-interpolate, or read-and-time-derivative data from
        files, respectively; and
    <DT><A HREF = "#write"><STRONG><CODE>WRITE3()</CODE></STRONG></A>
        to store data to files.
</DL>
</BLOCKQUOTE>
There is one master Fortran-90 <CODE>MODULE</CODE>,
<A HREF="M3UTILIO.html"><STRONG><CODE>MODULE&nbsp;M3UTILIO</CODE></STRONG></A>,
which provides declarations and Fortran-90 <CODE>INTERFACE</CODE>s
for the routines, as well as incorporating three <CODE>INCLUDE</CODE>
files you'll have to worry about:
<BLOCKQUOTE>
<DL>
    <DT><A HREF = "INCLUDE.html#parms"><STRONG><VAR>PARMS3.EXT</VAR></STRONG>
        for Fortran and <STRONG><VAR>parms3.h</VAR></STRONG> for C</A>
        <DD> contain the dimensioning parameters and the &quot;magic
        number&quot;  parameters used to control the operation of
        various routines in the I/O&nbsp;API;
        <P>
    <DT><A HREF = "INCLUDE.html#fdesc"><STRONG><VAR>FDESC3.EXT</VAR></STRONG>
        for Fortran and <STRONG><VAR>fdesc3.h</VAR></STRONG> for C</A>
        <DD> have <CODE>COMMON</CODE>s or <CODE>struct</CODE>s that hold file
        descriptions (more about that later); <VAR>FDESC3.EXT</VAR>
        needs  <VAR>PARMS3.EXT</VAR> for its own dimensioning; and
        <P>
    <DT><A HREF = "INCLUDE.html#iodecl"><STRONG><VAR>IODECL3.EXT</VAR></STRONG>
        for Fortran and <STRONG><VAR>iodecl3.h</VAR></STRONG> for C</A>
        <DD> have declarations and usage comments for the various functions in
        the  I/O&nbsp;API (really a short manual on the
        I/O&nbsp;API in its own right).<BR>
        <VAR>iodecl3.h</VAR> automatically <VAR>#include</VAR>s both
        <VAR>parms3.h</VAR> and <VAR>fdesc3.h</VAR>
        <P>
</DL>
</BLOCKQUOTE>
Each of these <CODE>INCLUDE</CODE>-files has extensive in-line documentation describing how it is used.
<P>
Normally, Fortran routines that use the I/O&nbsp;API should begin as
follows,  to define all these declarations, <CODE>PARAMETER</CODE>s and
<CODE>INTERFACE</CODE>s:
<STRONG><PRE>
    ...
    USE M3UTILIO
    ...
</PRE></STRONG>
C codes should similarly
<STRONG><PRE>
    ...
    #include "iodecl3.h"
    ...
</PRE></STRONG>
</BLOCKQUOTE>

<HR>

     <H2> <A NAME = "files">
     Files , Logical Names and Physical Names
    </A> </H2>

<BLOCKQUOTE>
The I/O&nbsp;API stores and retrieves data using
<A HREF = "BUFFERED.html"><STRONG>files</STRONG> and  <STRONG>virtual
files</STRONG></A>, which have (optionally) multiple
<A HREF = "DATATYPES.html#timestruct">time steps</A> of multiple
<A HREF = "VBLE.html">layers of multiple variables</A>.  Files are
formatted internally so that they are machine and network-independent&mdash;you
can FTP them freely across a wide variety of machines, or read  files
NFS-mounted from other machines, as well.  (This behavior is  unlike
Fortran files, whose internal formats are vendor specific, so  that the
files don't FTP or NFS-mount very well, and aren't even necessarily
compatible from compiler-version to compiler version).  Each file has an
internal description, consisting of the  <A HREF = "DATATYPES.html">file
type</A>, the  <A HREF = "GRIDS.html">grid and coodinate
descriptions</A>, a set of  descriptions for the file's set of
<STRONG>variables</STRONG>, i.e., names,  units specifications, and text
descriptions.  Each variable has a set of  <STRONG>layers</STRONG> and a
sequence of <STRONG>time steps</STRONG>  (quite possibly only one layer
for some kinds of data, if you want, or only  one time step, for
time-independent data).  In dealing with the files,  we'll refer to
files and variables by names, layers by number (from 1  to the number
of layers in the file), and dates and times according  to
<A HREF="DATETIME.html">conventions described later</A>.  Rather than
forcing the programmer  and program-user to deal with hard-coded file
names or hard-coded  unit numbers, the I/O&nbsp;API introduces the
concept of  <A HREF = "LOGICALS.html"><STRONG>logical file
names</STRONG></A>.   As a modeler, you can define your own logical
names as  properties of a program (or even prompt the user for his own
preferred logical names at run time) and then at run-time connect up
the  logical names to any &quot;real&quot; file name you want to, using
the  UNIX <VAR>csh&nbsp;setenv</VAR> command.  Additionally, there are four
<A HREF = "ENVIRONMENT.html">standard logical names</A>:
<BLOCKQUOTE>
<DL>
    <DT> <VAR>LOGFILE</VAR> for the program log file (if desired);
    <DT> <VAR>SCENFILE</VAR> for the scenario (run-) description file;
    <DT> <VAR>EXECUTION_ID</VAR> for a one-line-text
            run-description/identifier; and
    <DT> <A HREF="GRIDDESC.html"><VAR>GRIDDESC</VAR></A>, for the
            ASCII grid and  coordinate system databases used by utility
            routine <A HREF="DSCGRID.html"><CODE>DSCGRID()</CODE></A>.
</DL>
</BLOCKQUOTE>
For programming purposes, the significant facts are that names should
not contain arithmetic operations (<CODE>+-*/</CODE>), or blanks (except
at the end:
<CODE>&quot;foo&nbsp;&quot;</CODE> is OK;
<CODE>&quot;f&nbsp;oo&quot;</CODE> is not), and are at most 16
characters long.
<P>

When you run a program that uses the I/O&nbsp;API, you begin with the
sequence of <VAR>setenv</VAR> commands that set the values for the
program's logical names, much as you begin a (normal) Cray Fortran
program with a sequence of <VAR>ASSIGN</VAR> commands for its files.
For example, if &quot;<VAR>myprogram</VAR>&quot; has logical names
&quot;<VAR>foo</VAR>&quot; and &quot;<VAR>bar</VAR>&quot; that I
want to connect up to files &quot;<VAR>somedata.mymodel</VAR>&quot;
and &quot;<VAR>otherdata.whatever</VAR>&quot; from directory
&quot;<VAR>/tmp/mydir</VAR>&quot;, the script for the program would
look something like:
<PRE>
    ...
    setenv foo          /tmp/mydir/somedata.mymodel
    setenv bar          /tmp/mydir/otherdata.whatever
    setenv qux         &quot;/tmp/mydir/volatilestuff.mymodel -v&quot;
    setenv LOGFILE      /tmp/mydir/mymodel.log
    setenv SCENFILE     /tmp/mydir/test17a.description
    setenv EXECUTION_ID TEST17A
    /user/mydir/myprogram
    ...
</PRE>

<A HREF="BUFFERED.html#pncf">PnetCDF/MPI distributed files</A>  are indicated
by a leading <CODE>MPI:</CODE> prefix, e.g., 
<PRE>
    setenv foo       MPI:/tmp/mydir/somedata.mymodel
</PRE>
<P>

<A HREF="BUFFERED.html#vol">Native-binary files</A> (For NCEP) are indicated
by a leading <CODE>BIN:</CODE> prefix, e.g., 
<PRE>
    setenv bar       BIN:/tmp/mydir/somedata.mymodel
</PRE>
<P>

<A HREF="BUFFERED.html#vol">VOLATILE files</A>  are indicated by a
trailing <CODE>&nbsp;-v</CODE> in the <VAR>setenv</VAR> command, as
above, in order to tell the I/O&nbsp;API to perform disk-synch
operations before every input and after every output operation on that
file.  Such files can be accessed by other programs while the generating
program is still running, and are readable even if it fails to do a <A
HREF="SHUT3.html">SHUT3()</A> or <A HREF="M3EXIT.html">M3EXIT()</A>, or
if the program crashes unexpectedly).
<P>

<A HREF="BUFFERED.html#buf">BUFFERED virtual files</A> can be used to
provide safe, structured exchange of data &mdash; of &quot;gridded&quot;,
&quot;boundary&quot;, or &quot;custom&quot;  types only &mdash; between
different modules in the same program.  If you  <CODE>setenv</CODE>
the value of a logical name to the value  <CODE>BUFFERED</CODE>, as
given below:
<PRE>
    ...
    setenv qux BUFFERED
    ...
    /user/mydir/myprogram
    ...
</PRE>
then the I/O&nbsp;API will establish in-memory buffers and time indexing
for &quot;qux&quot; instead of creating a physical file on disk.  One module
can then use <A HREF = "#write"><CODE>WRITE3()</CODE></A> (see below) to
export data  for sharing, which other modules would then use
<A HREF="#read"><CODE>READ3()</CODE> or <CODE>INTERP3()</CODE></A> to import.
Note  that since these routines associate the data with its simulation
date-and-time, the system will notice the error (and warn the user)  if
you attempt to get and use data before it has been produced.   Note also
that by changing the <VAR>setenv</VAR> in the script between
&quot;BUFFERED&quot; and a physical file-name, you can change between
efficient data sharing between modules and high-resolution
instrumentation of the data being shared, without changing the
underlying program at all.
<P>

<A HREF="BUFFERED.html#pvm">COUPLING-MODE virtual files</A> can be
used to provide PVM-based data exchange between cooperating programs
using exactly the unchanged I/O&nbsp;API programming interface, with the
kind of name-based direct-access semantics that provides, with the
extra scheduling condition that requests for data that has not yet been
written put the requester to sleep until it becomes available (at which
time the requester is awaked and given the requested data).  The
decision of which files are disk-based and which are COUPLING-MODE
virtual files is also made by <VAR>setenv</VAR> commands at
program-launch, the value being of the form
<CODE>virtual&nbsp;&lt;communications-channel-name&gt;</CODE>
or <CODE>PVM:&lt;communications-channel-name&gt;</CODE> as in
one of the following:
<PRE>
    ...
    setenv  qux  PVM:CHEM_CONC_2D_G3
    setenv  zok  &quot;virtual CHEM_CONC_3D_G3&quot;
    /user/mydir/myprogram
    ...
</PRE>
<P>

Except for <CODE>INIT3()</CODE> (which returns the Fortran unit number
for the log file), all of the fundamental I/O&nbsp;API routines are
<CODE>LOGICAL</CODE> functions  returning <CODE>TRUE</CODE> for success
and <CODE>FALSE</CODE> for failure.
<P>

There are a number of <A HREF = "INCLUDE.html#dims">dimensioning</A>
parameters and <A HREF = "INCLUDE.html#magic">&quot;magic number&quot;</A>
token values for the I/O&nbsp;API.  Throughout the I/O&nbsp;API, names
(logical file  names, variable names, and units) are character strings
with maximum  length <CODE>NAMLEN3&nbsp;=&nbsp;16</CODE>; descriptions
are either one or  <CODE>MXDESC3&nbsp;=&nbsp;60</CODE> lines of length at
most <CODE>MXDLIN3&nbsp;=&nbsp;80</CODE>.   The I/O&nbsp;API currently
supports up to MXFILE3&nbsp;=&nbsp;64 open files,  each with up to
<CODE>MXVARS3&nbsp;=&nbsp;2048</CODE> variables
<EM>(<CODE>MXVARS3&nbsp;=&nbsp;120</CODE> for I/O&nbsp;API version 3.0 or
earlier).</EM>
<P>

</BLOCKQUOTE>
<HR>

<H2> <A NAME = "descriptions">
     What Are the File Descriptions and Types of Data Supported
    </A> </H2>

<BLOCKQUOTE>
The <A HREF = "INCLUDE.html#fdesc">include-files</A>
<STRONG><VAR>FDESC3.EXT</VAR></STRONG> for Fortran, and
<STRONG><VAR>fdesc3.h</VAR></STRONG> for C contain heavily annotated
declarations for all the variables in a file description, together with
the two commons which are used by the I/O&nbsp;API to store and retrieve
the file descriptions.  The <CODE>DESC3()</CODE> routine takes a file
and puts its description into the <CODE>FDESC3&nbsp;COMMON</CODE>s;
<CODE>OPEN3()</CODE> does roughly the reverse when dealing with new or
unknown files, taking a description from the <CODE>FDESC3</CODE> commons
and building a new file according to those specifications, or performing
a consistency check with the description stored in the file's header if
the file already exists.  A typical call to
<A HREF="DESC3.html"><CODE>DESC3()</CODE></A> might look like:
<PRE>
        ..
        IF ( .NOT. DESC3( 'myfile' ) ) THEN
        ...(error:  probably the file hasn't been opened yet)
        END IF
</PRE>

Some of the items in a file description, such as the dates and times
for file creation and update, and the name of the program which created
the file, are maintained automatically by the system.  Others describe
the variables in the file:  the file type (as described above), the
number of variables, their names, unit designations, and descriptions,
as well as the description of the file as a whole.  Still others
dimension the data:  the number of layers and the grid dimensions
(where for ID and profile files, the number of sites is mapped onto
the rows dimension; for profile files, the number of vertical levels
is mapped onto the columns dimension).  Still other parts of the file
description specify the geometry of the grid:  the map projection used,
its projection parameters, and the grid's location and cell-size
relative to that map projection; the vertical-grid-coordinate type
and the boundary values separating the model layers.

<P>

All files manipulated by the I/O&nbsp;API have multiple
<A HREF="VBLE.html">variables</A>, each
having possibly multiple layers.  Within a file, all the variables
are data arrays have the same dimensions, number of layers and the
same <A HREF = "DATATYPES.html#struct">structure-type of data</A>,
although possibly different <A HREF = "DATATYPES.html#basic">basic types</A>
(e.g., gridded and boundary varaibles can't be mixed within the same file,
but real and integer variables can).  Each file has a
<A HREF = "DATATYPES.html#timestruct">time step structure</A>
shared by all of its variables, as well.
There are three kinds of time-step structure supported:
<BLOCKQUOTE>
<DL>
    <DT>  <STRONG>Time-independent.</STRONG>  The file's time-step
    attribute is set to zero.<BR>
    Routines which deal with time-independent files ignore the date
    and time arguments.

    <DT>  <STRONG>Time-stepped.</STRONG>  The file has a starting date,
    a starting time,  and a positive time step.  Read and write requests
    must be for  some positive integer multiple of the time step from
    the starting  date and time, or they will fail.

    <DT>  <STRONG>Circular-buffer.</STRONG>  The file keeps only two
    &quot;records&quot;, the &quot;even&quot; part and the &quot;odd&quot;
    part (useful, for example, for &quot;restart&quot; files where you're
    only interested in the last good data in the file).  The file's
    description has a starting date, a starting time, and a negative
    time step (set to the negative of the actual time step); read and
    write requests must be for some positive integer multiple of the
    time step from the starting date and time -- and must be for a
    time step actually present -- or they will fail.
</DL>
</BLOCKQUOTE>
<STRONG>NOTE&nbsp;1:</STRONG> this is designed to support very-long time step sequences:
the author has performed 33-year runs with time steps as small as 30
minutes (over 500,000 time steps), and the access methods are designed
to support analysis and visualization of such large (&gt;3TB) data sets.
<P>
<STRONG>NOTE&nbsp;2:</STRONG> By convention, <STRONG>standard-year and
standard-week data</STRONG> are represented by using
<STRONG>year&nbsp;0</STRONG>:<BR>
for example, if one has monthly standard year data, one may store the
data in a file starting at Dec.&nbsp;16 of Year&nbsp;-1
(<CODE>JDATE=-650=-1000+350</CODE>, where <CODE>YYYY=(-1000),
DDD=350</CODE>), with time step 7300000 (30 days, 10 hours) and 14
time-steps (for December of Year&nbsp;(-1) through January of
Year&nbsp;1), to provide &quot;fenceposts&quot; for daily or hourly
interpolation using <CODE>INTERP3()</CODE>.<BR>
Similarly, a standard-week file might have starting date&amp;time
0000001:000000, time step 240000 (one day), and 7 time steps; one
would then use <CODE>CURRSTEP()</CODE> (described below) to determine
dates and times for <CODE>READ3()</CODE>.
<P>

There are eight <A HREF = "DATATYPES.html#struct">structure-types</A>
and four <A HREF = "DATATYPES.html#basic">basic types</A> of data
supported by the I/O&nbsp;API.  The structure-types are associated with
file type  parameter values (&quot;magic numbers&quot;)
<BLOCKQUOTE>
<DL>
    <DT> <STRONG><CODE>CUSTOM3</CODE></STRONG>, for single-indexed array
    with meaning to be defined by the user;
    <DT> <STRONG><CODE>DCTNRY3</CODE></STRONG>, for file-dictionary (not
    currently used);
    <DT> <STRONG><CODE>GRDDED3</CODE></STRONG>, for gridded data;
    <DT> <STRONG><CODE>BNDARY3</CODE></STRONG>, for grid-boundary data;
    <DT> <STRONG><CODE>IDDATA3</CODE></STRONG>, for ID-referenced (e.g.,
    observational) data;
    <DT> <STRONG><CODE>PROFIL3</CODE></STRONG>, for observational
    vertical-profile (e.g., rawindsonde) data;
    <DT> <STRONG><CODE>GRNEST3</CODE></STRONG>, for nest-of-grids data
    (not currently used); and
    <DT> <STRONG><CODE>SMATRX3</CODE></STRONG>, for sparse-matrix data.
</DL>
</BLOCKQUOTE>
(for which <CODE>GRDDED3</CODE> and <CODE>BNDARY3</CODE> will account for
almost all CTM uses); <CODE>CUSTOM3</CODE> and <CODE>SMATRX3</CODE>
are used primarily in emissions and hydrology modeling).
These <CODE>PARAMETER</CODE>s are defined in INCLUDE-file
<A HREF="INCLUDE.html">PARMS3.EXT</A>.
<P>

The basic types are associated with &quot;magic numbers&quot;
<BLOCKQUOTE>
<DL>
    <DT> <STRONG><CODE>M3INT</CODE></STRONG>,  for 4-byte (32-bit) <CODE>INTEGER</CODE>s
    <DT> <STRONG><CODE>M3REAL</CODE></STRONG>, for 4-byte (32-bit) <CODE>REAL</CODE>s
    <DT> <STRONG><CODE>M3DBLE</CODE></STRONG>, for 8-byte (64-bit)
         <CODE>REAL</CODE>s (i.e., <CODE>DOUBLE PRECISION</CODE>), and
    <DT> <STRONG><CODE>M3INT8</CODE></STRONG>, for 8-byte (64-bit) <CODE>INTEGER</CODE>s
            (<EM>I/O&nbsp;API-3.2 or later only, and if netCDF4 is enabled</EM>)
</DL>
</BLOCKQUOTE>
also defined in <CODE>INCLUDE</CODE>-file <VAR>PARMS3.EXT</VAR>.
Each of these data types supports multiple time steps of multiple layers
of multiple user-defined variables, as indicated below.  In some cases,
there are additional system-defined variables which are part of the data
structure (e.g., the <A HREF = "#numids"><CODE>NUMIDS</CODE> in the
ID-referenced data structure, below)</A> .  Where such system-defined
variables are present, the operations <CODE>READ3()</CODE> and
<CODE>WRITE3()</CODE> act on entire
time steps (all variables) at once; otherwise, they can be used to store
or retrieve time steps of individual variables one at a time.  There are
moderate performance advantages to writing the variables for a time step
in the same order that they appear in the file description, and for writing
the time steps in consecutive order; however, this is not required by the
I/O&nbsp;API (which permits any access order to the data, for both read and
write operations).  The structural types are as follows, together with
declarations for sample time step records of these data types:
(In the examples, declarations are given for <CODE>M3REAL</CODE> variables in terms
of <CODE>REAL*4</CODE>, etc, instead of merely <CODE>REAL</CODE>, to protect you in the cases that
your compiler has a &quot;-r8&quot; flag, etc., which silently changes all
<CODE>REAL</CODE>s from 4-byte to 8-byte -- and causes you accidentally to be linked
with an incompatible version of the library; if you never use this flag,
don't worry.)
<P>

For several of the &quot;structured&quot; data types below, neither
Fortran nor C data-structuring constructs are powerful enough to handle
the general case; one is often forced to use
single-indexing/data-overlay tricks such as those found here in
<A HREF="MTXCALC.txt"><VAR>m3tools</VAR> program <VAR>mtxcalc</VAR></A>.
<P>

The structure-types are:
<BLOCKQUOTE>
<DL>
    <DT> <STRONG><CODE>CUSTOM3</CODE></STRONG> = -1:
    <DD> custom data--variables are just user-dimensioned
    arrays of data that the system reads and writes reliably; it's
    up to you to interpret its structure for yourself.  (This one
    was included on the &quot;I probably haven't thought of everything&quot;
    principle, and then turned out to be very useful for
    emissions-source files.)
<PRE>
        ...(SIZE is a fixed, user-defined dimension:)
        REAL*4  ARRAY( SIZE, NLAYS, NVARS )
</PRE>

    <DT>  <STRONG><CODE>DCTNRY3</CODE></STRONG> = 0:
    <DD> <EM>currently unused</EM><BR>
    file-type dictionary--the reusable parts of a file description;
    this data type is used as an aid to model management, to store and
    retrieve the following parts of an
    <A HREF = "INCLUDE.html#fdesc">FDESC3.EXT</A> file description:
<PRE>
        FTYPE3D, TSTEP3D, NCOLS3D, NROWS3D, NLAYS3D, NVARS3D, NTHIK3D,
        GDTYP3D, P_ALP3D, P_BET3D, P_GAM3D, XORIG3D, YORIG3D, XCELL3D,
        YCELL3D, GDNAM3D, XCENT3D, YCENT3D, VNAME3D, UNITS3D, VDESC3D
</PRE>

    <DT>  <STRONG><CODE>GRDDED3</CODE></STRONG> = 1:
    <DD> gridded data, dimensioned as in:
<PRE>
    REAL*4  ARRAY( NCOLS, NROWS, NLAYS, NVARS )
</PRE>

    <DT>  <STRONG><CODE>BNDARY3</CODE></STRONG> = 2:
    <DD> boundary data for an external perimeter to a grid.
    This perimeter is <CODE>NTHIK</CODE> cells wide (where you may use a
    negative <CODE>NTHIK</CODE> to indicate an internal perimeter such as
    is used by ROM and RADM).  The boundary array is dimensioned
    as follows in terms of the dimensions <CODE>NCOLS</CODE> and
    <CODE>NROWS</CODE> for the array it surrounds:
<PRE>
    ...(SIZE = ABS( NTHIK )*(2*NCOLS + 2*NROWS +4*NTHIK)
    REAL*4  ARRAY( SIZE, NLAYS, NVARS )
</PRE>
    There are accompanying diagrams illustrating the data layout for
    various cases of <CODE>NTHIK</CODE>:
    <UL>
        <LI> the general thickened-boundary case, NTHIK &gt; 1, available
            as <A HREF = "THKBDY.ps">Postscript</A>,
            as <A HREF = "THKBDY.xbm">X11 Bitmap</A>,
            as <A HREF = "THKBDY.jpg">JPEG</A>, or
            as <A HREF = "THKBDY.gif">GIF</A>;
        <LI> the simple case, NTHIK = 1, available
            as <A HREF = "BDY.ps">Postscript</A>,
            as <A HREF = "BDY.xbm">X11 Bitmap</A>,
            as <A HREF = "BDY.jpg">JPEG</A>, or
            as <A HREF = "BDY.gif">GIF</A>;
        <LI> the internal-boundary case, NTHIK = -1 (&lt; 0), available
            as <A HREF = "INTBDY.ps">Postscript</A>,
            as <A HREF = "INTBDY.xbm">X11 Bitmap</A>,
            as <A HREF = "INTBDY.jpg">JPEG</A>, or
            as <A HREF = "INTBDY.gif">GIF</A>.
    </UL><P>

    <DT>  <STRONG><CODE><A NAME = "numids">IDDATA3</A></CODE></STRONG> = 3:
    <DD> ID-referenced data, used to store lists of data
    like surface meteorology observations, pollution-monitor observations,
    or county-averaged concentrations.  (ROM people note:  this is
    a generalization of ROM Type 2 and 3 files, except that if you
    want the positions  and elevations, you have to list them as
    variables yourself).  An example of observational data with up
    to 100 sites, each measuring temperature, pressure, and relative
    humidity (in addition to having an X-Y position) is the following:
<PRE>
    ...
    INTEGER*4   MAXID              !  max permitted # of sites
    PARAMETER ( MAXID = 100 )
    ...
    INTEGER*4   NUMIDS             !  number of actual sites
    INTEGER*4   IDLIST( MAXID )    !  list of site ID's
    REAL*4      XLON  ( MAXID )    !  first variable in file
    REAL*4      YLAT  ( MAXID )    !  second variable
    REAL*4      TK    ( MAXID )    !  third variable
    REAL*4      PRES  ( MAXID )    !  fourth variable
    REAL*4      RH    ( MAXID )    !  fifth (last) variable
    COMMON /FOO/ NUMIDS, IDLIST, XLON, YLAT, TK, PRES, RH
</PRE>
    NVARS3D is 5.
    The dimension <CODE>MAXID</CODE> maps into the <CODE>NROWS3D</CODE>
    dimension in the file description data structure <CODE>FDESC3.EXT,</CODE>
    for use by OPEN3() or DESC3().  To read or write this data, put the
    first element, <CODE>NUMIDS,</CODE> of  this common in the
    <CODE>array</CODE> spot of READ3(),
    WRITE3(), etc.:
<PRE>
    IF ( .NOT. WRITE3( 'myfile', 'ALL', JDATE, JTIME, NUMIDS ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>

    <DT>  <STRONG><CODE>PROFIL3</CODE></STRONG> = 4:
    <DD> vertical profile data (rawindsonde data), which
    has a sufficiently different structure from other observational data
    (having possibly a site-dependent number of levels at each site)
    that it deserves a special data type of its own.  (This is much
    like ROM Type 1 files.)   An example of the  sort of data structure
    needed for a rawinsonde file with NVARS3D = 3 variables <CODE>ELEV,
    TA,</CODE> and  <CODE>QV</CODE> given at up to 50 stations, each of
    which may have up  to 100 observation  levels, is given by the following.
    Note that  <CODE>ELEV</CODE> = &quot;height of the level above ground&quot;
    is user-specified as one of the variables rather than supplied by the
    system as for ROM Type 1 files.
<PRE>
    ...
    INTEGER*4   MXIDP             !  max # of sites
    INTEGER*4   MXLVL             !  max # of levels
    PARAMETER ( MAXID = 50, MXLVL = 100 )
    ...
    INTEGER*4   NPROF             !  # of actual sites
    INTEGER*4   PLIST( MXIDP )    !  list of site ID's
    INTEGER*4   NLVLS( MXIDP )    !  # of actual levels at site
    REAL*8      X    ( MXIDP )    !  array of site X-locations
    REAL*8      Y    ( MXIDP )    !  array of site Y-locations
    REAL*8      Z    ( MXIDP )    !  array of site Z-locations
    REAL*4      ELEV ( MXLVL, MXIDP )    !  height of lvl a.g.l.
    REAL*4      TA   ( MXLVL, MXIDP )    !  variable &quot;TA&quot;
    REAL*4      QV   ( MXLVL, MXIDP )    !  variable &quot;QV&quot;
    COMMON /BAR/ NPROF, PLIST, NLVLS, X, Y, Z, ELEV, TA, QV
    ...
</PRE>
    The site dimension <CODE>MXIDP</CODE> maps into the <CODE>NROWS3D</CODE>
    dimension , and the  levels dimension <CODE>MXLVL</CODE> maps into the
    <CODE>NCOLS3D</CODE> dimension in the  file description (FDESC3) data
    structures.   To read or write  this data, put the first element,
    <CODE>NPROF,</CODE> of the common BAR in the
    <CODE>array</CODE> spot of READ3(), WRITE3(), etc.:
<PRE>
    IF ( .NOT. WRITE3( 'myfile', 'ALL', JDATE, JTIME, NPROF ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>

    <DT>  <STRONG><CODE>GRNEST3</CODE></STRONG> = 5:
    <DD>  <EM>currently unused</EM><BR>
    nested-grid data should be considered as a preliminary and
    experimental implementation for storing multiple grids, which need
    not in fact have any particular relationship with each other beyond
    using the same coordinate system.  An example of the  sort of data
    structure needed for a nest of grids for the NVARS3D = 2 variables
    NO2 and O3 is the following:
<PRE>
    ...
    INTEGER*4   MXNEST            !  max # of nests
    INTEGER*4   MXGRID            !  max # of cells (total, all grids)
    INTEGER*4   MXLAYS            !  max # of levels
    PARAMETER ( MXNEST = 10, MXGRID = 10000, MXLAYS = 25 )
    ...
    INTEGER*4   NNEST              !  # of actual nests
    INTEGER*4   NLIST( MXNEST )    !  list of nest ID's
    INTEGER*4   NCOLS( MXNEST )    !  # of actual cols of nest
    INTEGER*4   NROWS( MXNEST )    !  # of actual rows of nest
    INTEGER*4   NLAYS( MXNEST )    !  # of actual lays of nest
    REAL*8      XN   ( MXNEST )    !  array of nest X-locations
    REAL*8      YN   ( MXNEST )    !  array of nest Y-locations
    REAL*8      DX   ( MXNEST )    !  array of nest cell-size DX's
    REAL*8      DY   ( MXNEST )    !  array of nest cell-size DY's
    REAL*4      NO2  ( MXGRID, MXLAYS, MXNEST )    !  variable &quot;NO2&quot;
    REAL*4      O3   ( MXGRID, MXLAYS, MXNEST )    !  variable &quot;O3&quot;
    COMMON /QUX/ NNEST, NLIST, NCOLS, NROWS, NLAYS,
 &amp;               XN, YN, DX, DY, NO2, O3
    ...
</PRE>
    The nest dimension <CODE>MXNEST</CODE> maps into the <CODE>NROWS3D</CODE>
    dimension, the cells  dimension <CODE>MXGRID</CODE> maps onto
    <CODE>NCOLS3D,</CODE> and the layers dimension <CODE>MXLAYS</CODE>
    maps onto <CODE>NLAYS3D</CODE> in the file description (FDESC3) data
    structures.   To read or write this data, put the first element,
    <CODE>NNEST,</CODE> of this  common <CODE>QUX</CODE> in the
    <CODE>ARRAY</CODE> spot of READ3(), WRITE3(), etc.:
<PRE>
    IF ( .NOT. WRITE3( 'nfile', 'ALL', JDATE, JTIME, NNEST ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>

    <DT>  <STRONG><CODE>SMATRX3</CODE></STRONG> = 6:
    <DD> sparse matrix data, which uses a &quot;skyline-transpose&quot;
    representation for sparse matrices, such as those found in the
    emissions model prototype.  An example of the sort of data
    structure needed for these sparse matrices is the following:
<PRE>
    ...
    INTEGER     NASRC   !  total # of active cols (added over all rows)
    INTEGER     NGRID   !  number of rows in the matrix
    PARAMETER ( NASRC = 39978, NGRID = 5400 )
    ...
    INTEGER     NS( NGRID )     !  # of actual cols per row
    INTEGER     IS( NACEL )     !  column pointers
    REAL        CS( NACEL )     !  col-coefficients

    COMMON  / GRIDMAT / NS, IS, CS
</PRE>
    In this case, <CODE>NVARS3D&nbsp;=&nbsp;1</CODE> and
    <CODE>NLAYS3D&nbsp;=&nbsp;1</CODE>. In the case of
    <CODE>NVARS3D&nbsp;&gt;&nbsp;1</CODE>, multiple coefficient matrices
    would share the same <CODE>NS</CODE> and <CODE>IS</CODE> arrays,
    and similarly if <CODE>NLAYS3D&nbsp;&gt;&nbsp;1</CODE>. The
    active-columns dimension <CODE>NASRC</CODE> maps into the
    <CODE>NCOLS3D</CODE> dimension and the matrix-rows dimension
    <CODE>NGRID</CODE> maps into the <CODE>NROWS3D</CODE> dimension in
    the file description (<CODE>FDESC3</CODE>) data structures.   To
    read or write this data, put the first element, <CODE>NS</CODE> of
    the common <CODE>GRIDMAT</CODE> in the <CODE>array</CODE> spot of
    <CODE>READ3(), WRITE3(),</CODE> etc., as below.
<PRE>
    IF ( .NOT. WRITE3( 'mfile', 'ALL', JDATE, JTIME, NS ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>
    Alternatively, &quot;over-dimension&quot; <CODE>NS</CODE>
    and use Fortran-77 style calls to reference <CODE>IS</CODE>
    and <CODE>CS</CODE>:
<PRE>
    ...
    INTEGER     NS( NGRID + 2*NACELL*NGRID )
    ...
    CALL BLDMTX( NGRID, NASRC, NS, NS(NGRID+1), NS(NGRID+NACEL+1) )
    ...
    IF ( .NOT. WRITE3( 'mfile', 'ALL', JDATE, JTIME, NS ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>
where
<PRE>
    SUBROUTINE BLDMTX( NGRID, NASRC, NS, IS, CS )
        INTEGER, INTENT(IN   ) :: NGRID, NASRC
        INTEGER, INTENT(  OUT) :: NS( NGRID )
        INTEGER, INTENT(  OUT) :: IS( NASRC )   !! in caller: NS(NGRID+1:NGRID+NACEL)
        REAL   , INTENT(  OUT) :: CS( NASRC )   !! in caller: NS(NGRID+NACEL+1: )
        ...
</PRE>
    For I/O&nbsp;API-3.2 and later, see routines
    <A HREF = "MODATTS3.html#initmtxatt">INITMTXATT()</A>,
    <A HREF = "MODATTS3.html#setmtxatt">SETMTXATT()</A>,
    <A HREF = "MODATTS3.html#getmtxatt">GETMTXATT()</A>,
    <A HREF = "MODATTS3.html#chkmtxatt">CHKMTXATT()</A>,
    which may be used to store, retrieve, and perform consistency-checks
    on extra file-header metadata for the input and output grid
    descriptions for matrix files.
    <P>

</DL>
</BLOCKQUOTE>
</BLOCKQUOTE>

<HR>

     <H2> <A NAME = "start">
     How to Start Up and Shut Down the I/O&nbsp;API
    </A> </H2>

<BLOCKQUOTE>
In order for the I/O&nbsp;API to start itself up correctly, and in order to
make sure that files are closed (and that file headers are updated)
correctly, you need to call the <CODE>INIT3()</CODE> function at the start of your
program, and the <CODE>SHUT3()</CODE> function (which flushes headers for, and
closes <EM>all</EM> files currently open) at the end, or else the <CODE>CLOSE3()</CODE>
function for each file opened.  Note that the utility routine
<A HREF = "M3EXIT.html"><CODE>M3EXIT()</CODE></A>, when used to shut down
a program, will call <CODE>SHUT3()</CODE> correctly (as well as writing explanatory
messages to the log).
<P>

<A HREF = "INIT3.html"><STRONG><CODE>INIT3()</CODE></STRONG></A> is an integer
function for initializing the I/O&nbsp;API, and must be called before
any other I/O API operation.  It returns the unit number to be used
for the program's log (if you <CODE>setenv&nbsp;LOGFILE&nbsp;&lt;path&gt;</CODE>,
the I/O&nbsp;API's log and error messages will be written to this unit;
otherwise, they go to standard output, unit 6).  <CODE>INIT3()</CODE>
can be called as many times as you want, to get the unit number for the
program log.
<P>

<A HREF = "SHUT3.html"><STRONG><CODE>SHUT3()</CODE></STRONG></A> is a logical
function that returns <CODE>TRUE</CODE> if the system successfully flushed all I/O&nbsp;API
files to disk and shut itself down, and <CODE>FALSE</CODE> if it failed.  If it failed,
there probably was a hardware problem -- not much you can do about it, but
at least you ought to be able to know.  It is legal to call <CODE>SHUT3()</CODE>
and close down all files currently open, and then to call <CODE>INIT3()</CODE> again
and open new ones.
<P>

<A HREF = "M3EXIT.html"><STRONG><CODE>M3EXIT()</CODE></STRONG></A> is
the routine used for <STRONG>normal program-termination</STRONG>.  It calls
<CODE>SHUT3()</CODE> as the final step of its operation, after writing a
user supplied message with the  current simulation date-and-time to the
program log, and then returns the program's exit status (0 for normal
completion, non-zero for program-failure) to the operating system.
<P>

<A HREF = "CLOSE3.html"><STRONG><CODE>CLOSE3()</CODE></STRONG></A> is a logical
function that returns TRUE if the system successfully flushed the
indicated file to disk and closed it, and FALSE if it failed.  It should
not be used by modeling programs, because its use destroys modularity;
it was intended for use only by long-running visualization programs.
<P>
</BLOCKQUOTE>

<HR>

     <H2> <A NAME = "open">
     How to Open (Create) and Get Descriptive Info About Files
    </A> </H2>

<BLOCKQUOTE>
<A NAME="open">Use</A> <A HREF="OPEN3.html"><STRONG><CODE>OPEN3(FNAME,FSTATUS,PGNAME)</CODE></STRONG></A>
to open files, whether files that already exist or files that are new.
<CODE>OPEN3()</CODE> is a logical function that return <CODE>TRUE</CODE>
when it succeeds, and <CODE>FALSE</CODE> when it fails.  It also
maintains much audit trail information stored in the file header
automatically, and automates various logging activities.  A couple of
additional pieces of audit trail information requires a bit of work from
you in setting up <A HREF = "ENVIRONMENT.html">standard environment
variables</A>, if you want to take advantage of it:  if you define the
description of your program run in a text file of up to 60 lines of up
to 80 characters each, and then <VAR>setenv&nbsp;SCENFILE</VAR> to that file
before you run the program, then <CODE>OPEN3()</CODE> will copy the
<VAR>SCENFILE</VAR> information into the <CODE>UPDSC3D</CODE> field in
the headers of any output files for that program.  Also, if you
<VAR>setenv&nbsp;EXECUTION_ID</VAR> to your own identifier (up to
80-character quoted line) for the program execution, it will automate
the storage and the logging of that identifier in the
<CODE>EXECN3D</CODE> field .  Finally, if you <VAR>setenv
IOAPI_CHECK_HEADERS&nbsp;YES</VAR>, then the I/O&nbsp;API will perform a
sanity check on internal file descriptions -- checking that grid
description parameters are in range, for example, or that vertical
levels are either systematically increasing or systematically
decreasing.
<P>

The arguments to <CODE>OPEN3()</CODE> are the logical name <CODE>FNAME</CODE> 
of the file, an <CODE>INTEGER</CODE> &quot;magic number&quot; 
<CODE>FSTATUS</CODE> indicating the type of open operation and the
caller's name  <CODE>PGNAME</CODE> for logging and audit-trail
purposes.  You can call <CODE>OPEN3()</CODE> many times for the same
file without hurting anything, if you want -- as long as you don't first
open it read-only and then try to change your mind and then open it for
output, or try to open it as a <CODE>NEW</CODE> file after it is already
open.  Names and values for the mode-of-opening magic number argument
are defined in <A HREF = "INCLUDE.html#parms"><STRONG><VAR>PARMS3.EXT</VAR></STRONG></A>
as the following:
<BLOCKQUOTE>
<DL>
    <DT>  <STRONG><CODE>FSREAD3</CODE></STRONG> = 1 for READ-ONLY access to
          an existing file <BR>
          <EM>This is the mode that should be used for input files.</EM>
          <P>

    <DT>  <STRONG><CODE>FSRDWR3</CODE></STRONG> = 2 for READ/WRITE/UPDATE
          access to an existing file <BR>
          <EM>rarely used</EM>
          <P>

    <DT>  <STRONG><CODE>FSNEW3</CODE></STRONG> = 3 for READ/WRITE access to create
          a new file (file must not yet exist)<BR>
          <EM>should be rarely used; leads to obscure &quot;why is my program
          failing?&quot; errors</EM>
          <P>

    <DT>  <STRONG><CODE>FSUNK3</CODE></STRONG> = 4 for READ/WRITE/UPDATE access to a file
          whose existence is unknown (creates the file if it does not
          yet exist, otherwise, performs consistency checks with the
          user-supplied file definition).<BR>
          <EM>This is the mode that should normally be used for output files.</EM>
          <P>

    <DT>  <STRONG><CODE>FSCREA3</CODE></STRONG> = 5 for CREATE/TRUNCATE/READ/WRITE
          access to files:  If the file is open, close it.  If the file
          exists, delete it.  Then create a new file according to the
          user-supplied file definition.<BR>
          <EM><STRONG>NOTE: </STRONG>dangerous, but the Powers That
          BE&reg; insisted.<BR>
          Joan Novak (EPA)  and Ed Bilicki (MCNC)
          have declared as a software standard that <STRONG>modeling programs
          may not  use <CODE>FSCREA3</CODE> as the mode for opening files.</STRONG>
          <CODE>FSCREA3</CODE> is reserved for use by analysis/data extraction programs
          only.</EM>
          <P>

</DL>
</BLOCKQUOTE>

In the last three cases, &quot;new&quot; &quot;unknown&quot; and
&quot;create/truncate,&quot; you fill in the file description from
the <CODE>INCLUDE</CODE> file
<STRONG><A HREF="INCLUDE.html#fdesc"><VAR>FDESC3.EXT</VAR></A></STRONG>
to define the structure for the file, and then call <CODE>OPEN3()</CODE>.
If the  file doesn't exist in either of these cases,
<CODE>OPEN3()</CODE> will use the  information to create a new file
according to your specifications,  and open it for read/write access.
In the &quot;unknown&quot;case,  if the file already exists,
<CODE>OPEN3()</CODE> will perform a consistency check  between your
supplied file description and the description found in  the file's own
header, and will return <CODE>TRUE</CODE> (and leave the file open)
only if the two are consistent.  Sample calls to <CODE>OPEN3()</CODE>
for an  input file 'myfile' and an output file 'my_newfile' might look
like  the following:
<PRE>
    ...
    IF ( .NOT OPEN3( 'myfile', FSREAD3, 'my program') ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
    ...
    ...  (First, fill in the file's description for 'my_newfile' here.
    ...   Then open it:)
    IF ( .NOT. OPEN3( 'my_newfile', FSNEW3, 'my program' ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>
There are also <A HREF = "SAMPLE.html">several sample programs</A> that
demonstrate how to use the I/O&nbsp;API to create various kinds of files --
gridded, boundary, and ID-referenced, with one or multiple layers, and
either time-stepped or time-independent.
<P>

<A NAME = "desc">To</A> get a file's description, you use the
<A HREF = "DESC3.html"><STRONG><CODE>DESC3(FNAME)</CODE></STRONG></A>
function.   When you call <CODE>DESC3()</CODE>, it puts the file's
complete description in the  standard file description data structures
in  <A HREF = "INCLUDE.html#fdesc"><VAR>FDESC3.EXT</VAR></A>. Note that
the file must have been opened prior to calling <CODE>DESC3()</CODE>.  
A typical output-file call sequence might look like:
<PRE>
    ...
    IF ( .NOT. OPEN3( 'myfile', FSUNKN3, 'myprogram' ) ) THEN
    ...(some kind of error happened--deal with it here)
    ELSE IF ( .NOT. DESC3( ' myfile' ) ) THEN
    ...(some kind of error happened--deal with it here)
    ELSE
    ...(the FDESC3 commons now contain the file description:
    ... data type, dimensions, starting date&amp;time, timestep,
    ... list of variables and their descriptions, etc.)
    END IF
    ...
</PRE>
<P>
</BLOCKQUOTE>

<HR>

     <H2> <A NAME = "read">
     How to Read Data from Files
    </A></H2>

<BLOCKQUOTE>
There are four routines with varying kinds of selectivity used to read
or otherwise retrieve data from files:
<A HREF = "READ3.html"  ><CODE>READ3()</CODE></A> ,
<A HREF = "XTRACT3.html"><CODE>XTRACT3()</CODE></A> ,
<A HREF = "INTERP3.html"><CODE>INTERP3()</CODE></A> , and
<A HREF = "DDTVAR3.html"><CODE>DDTVAR3()</CODE></A>.  All of
them are logical functions that return <CODE>TRUE</CODE> when they
succeed, <CODE>FALSE</CODE> when  they fail.
<BLOCKQUOTE>
<DL>
    <DT>  <STRONG><CODE>READ3(FNAME,VNAME,LAYER,JDATE,JTIME,BUFFER)</CODE></STRONG>
    <DD>  reads one variable <CODE>VNAME</CODE> or all variables (if <CODE>VNAME=ALLVARS3='ALL'</CODE>)
          and one or all layers (if <CODE>LAYER=ALLAYSS3=-1</CODE>) from
          the file <CODE>FNAME</CODE> for a particular date and time
          <CODE>JDATE:JTIME</CODE>;
          <P>

    <DT>  <STRONG><CODE>XTRACT3(FNAME,VNAME,LAY0,LAY1,ROW0,ROW1,COL0,COL1,JDATE,JTIME,BUFFER)</CODE></STRONG>
    <DD>  reads a windowed subgrid <CODE>BUFFER=GRID(COL0:COL1,ROW0:ROW1,LAY0:LAY1)</CODE>
          where <CODE>FNAME</CODE> must be of type <CODE>GRDDED3</CODE>, with full-grid
          array dimensions <CODE>GRID(NCOLS3D,NROWS3D,NLAYS3D)</CODE>.
          Otherwise, it is much like <CODE>READ3()</CODE>;
          <P>

    <DT>  <STRONG><CODE>INTERP3(FNAME,VNAME,CALLER,JDATE,JTIME,RSIZE,BUFFER)</CODE></STRONG>
    <DD>  time-interpolates the requested variable
          from the requested file to the requested date and time
          (optimizing disk accesses and interpolation-buffer
          manipulation internally behind the scenes). <CODE>FNAME</CODE>
          must have type <CODE>GRDDED3, CUSTOM3, </CODE> or
          <CODE>BNDARY3</CODE>,  and
          <CODE>RSIZE=NCOLS3D*NROWS3D*NLAYS3D</CODE> must be the total
          array-size.
          <P>

    <DT>  <STRONG><CODE>DDTVAR3(FNAME,VNAME,CALLER,JDATE,JTIME,RSIZE,BUFFER)</CODE></STRONG>
    <DD>  computes the time-derivative, much as <CODE>INTERP3()</CODE> time-interpolates.
          <P>
</DL>
</BLOCKQUOTE>

The first two require that the time step you request be on the file --
they won't give you data for the half-hour, for example, if the file has
hourly data only.  Because it optimizes the interpolation problem for
you, <CODE>INTERP3()</CODE> is probably the most useful of these
routines.  Note that it has a <CODE>size</CODE> argument -- you tell it
how much data you expect, and it checks that against how much data the
file thinks you ought to get, for error checking purposes.  A typical
<CODE>INTERP3()</CODE> call to read/interpolate the variable
<CODE>HNO3</CODE> to 12:37&nbsp;PM on February&nbsp;4, 1987 (Models-3
Convention date&amp;time 1987035:123000) might look like:
<PRE>
        ...
        CHARACTER*16 FNAME, VNAME
        REAL*4       ARRAY( NCOLS, NROWS, NLAYS )
        ...
        IF ( .NOT. INTERP3( 'myfile', 'HNO3', 1987035, 123700,
        &amp;                   NCOLS*NROWS*NLAYS, ARRAY ) ) THEN
        ...(some kind of error happened--deal with it here)
        END IF
</PRE>
With <CODE>READ3()</CODE> and <CODE>XTRACT3()</CODE>, you can use the
<A HREF = "INCLUDE.html#magic">&quot;magic values&quot; </A>
<CODE>ALLVAR3'</CODE> (= 'ALL', defined in
<A HREF = "INCLUDE.html#parms"><VAR>PARMS3.EXT</VAR></A>) or
<CODE>ALLAYS3</CODE> (= -1, also defined in <VAR>PARMS3.EXT</VAR>) as
variable name and/or layer number
to read all variables or all layers from the file, respectively.
<P>
For time independent files, the date and time arguments are ignored.
<P>
</BLOCKQUOTE>

<HR>

     <H2>  <A NAME = "write">
     How to Write Data to Files
    </A> </H2>

<BLOCKQUOTE>
You use the logical function
<A HREF = "WRITE3.html"><STRONG><CODE>WRITE3(FNAME,VNAME,JDATE,JTIME,BUFFER)</CODE></STRONG></A>
to write data to files.  For gridded, boundary, and custom files, you
may write either one time step of one variable at a time, or one entire
time step of data at a time (in which case, use
<A HREF = "INCLUDE.html#magic">&quot;magic value&quot;</A>
<CODE>ALLVAR3</CODE> (<CODE>='ALL'</CODE>, defined in
<A HREF = "INCLUDE.html#parms"><CODE>PARMS3.EXT</CODE></A>) as the
variable-name).  For ID-referenced,
profile, and grid-nest files, you must write an entire time step at a time
(i.e., the variable-name <EM>must</EM> be <CODE>ALLVAR3</CODE>).
<CODE>WRITE3()</CODE> is affected by <A HREF = "ENVIRONMENT.html">standard
environment variable <VAR>IOAPI_LOG_WRITE</VAR></A> (which has default value
&quot;YES&quot;); normally <CODE>WRITE3()</CODE> generates a log message for each
write-operation successfully completed.  However, if you
<CODE>setenv&nbsp;IOAPI_LOG_WRITE&nbsp;NO</CODE> then these messages will be
suppressed.  Typical <CODE>WRITE3()</CODE> calls to write data for date and time
<CODE>JDATE:JTIME</CODE> might look like the following:
<PRE>
    ...
    REAL*4       ARRAYA( NCOLS, NROWS, NLAYS )
    REAL*4       ARRAYB( NCOLS, NROWS, NLAYS, NVARS )
    ...
    IF ( .NOT. WRITE3( 'myfile', 'HNO3', JDATE, JTIME, ARRAYA ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
    IF ( .NOT. WRITE3( 'afile', 'ALL', JDATE, JTIME, ARRAYB ) )  THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>

<P>
</BLOCKQUOTE>

<HR>

     <H2> <A NAME = "datetime">
     Dates and Time Conventions, and <BR>
     How to Manipulate Them
    </A> </H2>

<BLOCKQUOTE>
Throughout the EDSS and Models-3 systems -- and particularly in the
I/O&nbsp;API -- <A HREF = "DATETIME.html">dates and times</A>
(and time-steps) are stored as integers, using the coding formats
<PRE>
    HHMMSS  = 10000 * hour  +  100 * minutes  +  seconds
    YYYYDDD =  1000 * year  +  day
</PRE>
where the year is 4-digits (1994, say, rather than just 94), and the
day is the Julian day-number (1,...,365 or 366).  By convention,
dates and times are <STRONG>stored in Greenwich Mean Time.</STRONG>
<P>

There are a number of <A HREF="AA.html#datestuff"><STRONG>utility
routines</STRONG> for date and time manipulation, </A>, as well as a
number of <A HREF="AA.html#datepgms"><STRONG>programs</STRONG> for date
and time manipulation</A>; some of these programs are designed for
interactive use, others for scripting.  The most frequently used of
these programs are
<A HREF = "JULDATE.html"><STRONG><VAR>juldate</VAR></STRONG></A>,
for converting calendar dates to Julian dates, and
<A HREF = "GREGDATE.html"><STRONG><VAR>gregdate</VAR></STRONG></A>,
for converting Julian dates to calendar dates and reporting the
day-of-the-week.  Both of these programs also report whether daylight
savings time is in effect for  the specified date.
<P>

The most frequently used utility routines for manipulating dates and
times are described below.   Note that for these routines, time steps
may perfectly well be  negative -- just make sure you keep the parts all
positive or  all negative; a time step of  -33000  means to step three
and a half  hours into the past, for example.  This way of representing
dates and  times is easy to understand and manipulate when you are
watching code  in the debugger (you don't have to turn &quot;seconds
since Jan.&nbsp;1, 1970&quot;  into something meaningful for your model run,
nor do you have to remember  whether April has 30 days or 31 when your
model run crosses over from  April to May).  Some useful utility
routines for manipulating dates and times  are the following:
<BLOCKQUOTE>
<DL>
    <DT>  <A HREF = "NEXTIME.html">
          <STRONG><CODE>NEXTIME( JDATE, JTIME, TSTEP )</CODE></STRONG></A>
          is a subroutine which updates date and time
          <CODE>JDATE:JTIME</CODE> by the
          time step <CODE>TSTEP</CODE> (which may be either positive or negative);
          <P>

    <DT>  <A HREF = "LASTTIME.html">
          <STRONG><CODE>LASTTIME( SDATE,STIME,TSTEP,NRECS, EDATE,ETIME )</CODE></STRONG></A>
          is a subroutine which computes the ending date&amp;time
          <CODE>EDATE:ETIME</CODE> for a time step sequence starting at
          <CODE>SDATE:STIME</CODE>, with time step <CODE>TSTEP</CODE>
          and <CODE>NRECS</CODE> steps.<BR>
          <EM>Safe from <CODE>INTEGER</CODE> overflow, even for multiple
          centuries</EM>;
          <P>

    <DT>  <A HREF = "TIME2SEC.html">
          <STRONG><CODE>TIME2SEC( TSTEP )</CODE></STRONG></A> is an integer function
          which returns the number of seconds in the time interval
          <CODE>TSTEP</CODE>;
          <P>

    <DT>  <A HREF = "SEC2TIME.html"><STRONG><CODE>SEC2TIME( SECS )</CODE></STRONG></A>
          is an  integer function which returns the time interval
          <CODE>HHMMSS</CODE>
          for the specified number of seconds;
          <P>

    <DT>  <A HREF = "SECSDIFF.html">
          <STRONG><CODE>SECSDIFF( ADATE, ATIME, ZDATE, ZTIME )</CODE></STRONG></A>
          is an integer function which returns the number of seconds
          from <CODE>ADATE:ATIME</CODE> to <CODE>ZDATE:ZTIME</CODE>;
          <BR>
          <EM>Subject to <CODE>INTEGER</CODE> overflow for periods
          longer than aboaut 21 years.</EM>
          <P>

    <DT>  <A HREF = "DT2STR.html">
          <STRONG><CODE>DT2STR( JDATE, JTIME )</CODE></STRONG></A> is a
          <CODE>CHARACTER*24</CODE> utility function which returns a
          string  for the date and time, as for example
          &quot;09:12:25&nbsp;April&nbsp;28,&nbsp;1994&quot;
          <P>

    <DT>  <A HREF = "CURRSTEP.html">
          <STRONG><CODE>CURREC( JDATE, JTIME, SDATE, STIME, TSTEP,
          CDATE, CTIME )</CODE></STRONG></A> is an <CODE>INTEGER</CODE>
          function which returns the record number for the time step
          that contains <CODE>JDATE:JTIME</CODE> in the time step
          sequence <CODE>SDATE:STIME:TSTEP</CODE>, even if
          <CODE>JDATE:JTIME</CODE>  is not an exact time step, and sets
          <CODE>CDATE:CTIME</CODE> to the exact date&amp;time for this
          time step sequence.  If <CODE>JDATE:JTIME</CODE> is before
          <CODE>SDATE:STIME</CODE>, returns -1.
          <P>

    <DT>  <A HREF = "HHMMSS.html"><STRONG><CODE>HHMMSS( JTIME )</CODE></STRONG></A>
          is a <CODE>CHARACTER*10</CODE> utility function which returns the
          string for the time &quot;HH:MM:SS&quot;
          (like the first field from <CODE>DT2STR()</CODE>);
          <P>

    <DT>  <A HREF = "ISDSTIME.html"><STRONG><CODE>ISDSTIME( JDATE )</CODE></STRONG></A>
          is a <CODE>LOGICAL</CODE> utility function which returns
          <CODE>TRUE</CODE> when daylight savings time is effect for
          <CODE>JDATE</CODE>
          <P>

    <DT>  <A HREF = "JSTEP3.html"><STRONG><CODE>JSTEP3( JDATE, JTIME, SDATE, STIME, TSTEP )</CODE></STRONG></A>
          is an <CODE>INTEGER</CODE> function which returns the timestep-record
          number corresponding to <CODE>JDATE:JTIME</CODE> if
          <CODE>JDATE:JTIME</CODE> is exactly
          on the timestep sequence, or -1 otherwise.
          <P>

    <DT>  <A HREF = "MMDDYY.html"><STRONG><CODE>MMDDYY( JDATE )</CODE></STRONG></A>
          is a <CODE>CHARACTER*14</CODE>  utility function which returns
          a   string &quot;Month&nbsp;DD,&nbsp;YYYY&quot;  for the date
          (like the second field from <CODE>DT2STR()</CODE>);
          <P>

    <DT>  <A HREF = "DAYMON.html">
          <STRONG><CODE>DAYMON( JDATE, MONTH, MDAY )</CODE></STRONG></A>  is a
          utility subroutine which returns the month (1, ..., 12) and
          day of month (1, ..., 31) for the specified Julian date;
          <P>

    <DT>  <A HREF = "WKDAY.html"><STRONG><CODE>WKDAY( JDATE )</CODE></STRONG></A>
          is a utility  integer function which returns the day-of-week
          (1=Monday, ..., 7=Sunday) for the  specified Julian date;
          <BR>
          <EM><STRONG>NOTE:</STRONG> Non-standard week (beginning with
          Monday instead of Sunday) dictated by the emissions
          modelers.</EM>
          <P>

    <DT>  <A HREF = "JULIAN.html">
          <STRONG><CODE>JULIAN( YYYY, MONTH, MDAY )</CODE></STRONG></A>
          is a utility integer function which returns the Julian day
          (1, ...,  365,366) for a specified year, month (1-12), and
          day of month (1-31).
          <P>
</DL>
</BLOCKQUOTE>
<P>
</BLOCKQUOTE>

<HR>

     <H2> <A NAME = "grids">
     Grid Conventions
    </A> </H2>

<BLOCKQUOTE>
See <A HREF="GRIDS.html">this page</A> for a more-complete description of
I/O&nbsp;API map-projection and grid-description conventions.
<P>

There are a number of utility routines for grid and coordinate related
tasks (such as coordinate-transforms and interpolation), which are
<A HREF="AA.html#coordstuff">indexed here</A>.  In particular, see
<A HREF="MODGCTP.html"><CODE>MODULE&nbsp;MODGCTP</CODE></A>, which provides
a number of routines that use the <A HREF="GCTP.html">USGS <CODE>GCTP</CODE>
coordinate-transformation package</A>.
<P>

A number of the <A HREF="AA.html#tools"><VAR><STRONG>m3tools</STRONG></VAR></A>
programs are designed for grid- and coordinate-related tasks.
Particularly notable are the following:
<BLOCKQUOTE>
<DL>
        <DT> <A HREF = "M3WNDW.html" ><STRONG><CODE>m3wndw</CODE></STRONG></A> and
             <A HREF = "BCWNDW.html" ><STRONG><CODE>bcwndw</CODE></STRONG></A>:
             extract data data from a gridded file to a subgrid window
             or its boundary.
        <P>
        <DT> <A HREF = "M3CPLE.html" ><STRONG><CODE>m3cple</CODE></STRONG></A>:
             copy to the same grid, or interpolate to another grid
             a time sequence of all variables from a source file to
             a target file, under the optional control of a
             &quot;synch file&quot;.
        <P>
        <DT> <A HREF = "MTXCALC.html" ><STRONG><CODE>mtxcalc</CODE></STRONG></A> and
             <A HREF = "MTXCPLE.html" ><STRONG><CODE>mtxcple</CODE></STRONG></A>:
             build a grid-to-grid sparse-matrix transform file using a
             sub-sampling algorithm, and use it to re-grid a time
             sequence of all variables from a source file to  a target
             file, respectively.
        <P>
        <DT> <A HREF = "PROJTOOL.html" ><STRONG><CODE>projtool</CODE></STRONG></A>:
             Perform coordinate conversions and grid-related
             computations,
        <P>
        <DT> <A HREF = "LATLON.html" ><STRONG><CODE>latlon</CODE></STRONG></A>:
             construct GRIDDED and/or BOUNDARY files with variables the
             cell-center <CODE>LAT</CODE> and <CODE>LON</CODE>.
        <P>
</DL>
</BLOCKQUOTE>
<P>
</BLOCKQUOTE>

<HR>

     <H2> <A NAME = "grids">
     Typical Modeling Program Outline
    </A> </H2>

<BLOCKQUOTE>

Here is an <A NAME="typical">example</A> of the typical outline for a
program that processes time stepped data (i.e., most modeling programs,
and most analysis programs), using the most-common I/O&nbsp;API routines:

<PRE>
PROGRAM MYPROGRAM
    ...
    USE M3UTILIO
    IMPLICIT NONE
    ...
    CHARACTER*16, PARAMETER :: PNAME = 'MYPROGRAM'
    CHARACTER*72, PARAMETER :: BAR   =  &
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-'
    ...
    INTEGER     LUNIT           ! <I> unit number for log file</I>
    INTEGER     ISTAT
    INTEGER     SDATE, STIME, TSTEP, NRECS
    INTEGER     JDATE, JTIME, N
    
    REAL        BARFAC      ! <I>used in computing BAR</I>

    INTEGER     NCOLS       ! <I>number of grid columns</I>
    INTEGER     NROWS       ! <I>number of grid rows</I>
    INTEGER     NLAYS       ! <I>number of layers</I>
    INTEGER     NTHIK       ! <I>bdy thickness</I>
    INTEGER     NVARS       ! <I>number of variables</I>
    INTEGER     GDTYP       ! <I>grid type:  1=LAT-LON, 2=Lambert, ...</I>
    INTEGER     VGTYP       ! <I>vertical coord type</I>
    REAL*8      P_ALP       ! <I>first, second, third map</I>
    REAL*8      P_BET       ! <I>projection descriptive</I>
    REAL*8      P_GAM       ! <I>parameters.</I>
    REAL*8      XCENT       ! <I>lon for coord-system X=0</I>
    REAL*8      YCENT       ! <I>lat for coord-system Y=0</I>
    REAL*8      XORIG       ! <I>X-coordinate origin of grid (map units)</I>
    REAL*8      YORIG       ! <I>Y-coordinate origin of grid</I>
    REAL*8      XCELL       ! <I>X-coordinate cell dimension</I>
    REAL*8      YCELL       ! <I>Y-coordinate cell dimension</I>
    REAL        VGTOP       ! <I>vertical coord top (for sigma coords)</I>
    REAL        VGLEV( MXLAYS3+1 )     ! <I> &quot;full&quot; levels</I>
    ...
    CHARACTER*256   MESG
    ...
    REAL, ALLOCATABLE ::  QV( :,:,: )
    REAL, ALLOCATABLE :: TA2( :,: )
    REAL, ALLOCATABLE :: BAR( :,: )
    ...
    !!.............  <I>begin body of program</I>  .......................

    LUNIT = INIT3()
    WRITE( LUNIT, '( 5X, A )' )  ' ',BAR, ' ',                              &amp;
'Program MYPROGRAM to compute BAR using data from files METCRO2D and',      &amp;
'METCRO3D, and write the result to file OUTCRO2D.',                         &amp;
'',                                                                         &amp;
'THE PROGRAM WILL PROMPT YOU for the starting and ending date&amp;time, and',   &amp;
'time step to process, and the factor BARFAC to use in the computation.',   &amp;
'',                                                                         &amp;
'PRECONDITIONS REQUIRED:',                                                  &amp;
'    setenv METCRO2D          &lt;path name&gt;',                                 &amp;
'    setenv METCRO3D          &lt;path name&gt;',                                 &amp;
'    setenv OUTCRO2D          &lt;path name for output file&gt;',                 &amp;
BAR, ''
    ...

    !!........  <I>Open input files.  Perform consistency checks.</I>
    
    IF ( .NOT.OPEN3( 'METCRO3D', FSREAD3, PNAME ) ) THEN
        CALL M3EXIT( PNAME, 0,0, 'Could not OPEN3(METCRO3D,...)', 2 )
    ELSE IF ( .NOT.DESC3( 'METCRO3D' ) ) THEN
        CALL M3EXIT( PNAME, 0,0, 'Could not DESC3(METCRO3D)', 2 )
    ELSE
        NCOLS = NCOLS3D
        NROWS = NROWS3D
        NLAYS = NLAYS3D
        GDTYP = GDTYP3D
        P_ALP = P_ALP3D
        P_BET = P_BET3D
        P_GAM = P_GAM3D
        XCENT = XCENT3D
        YCENT = YCENT3D
        XORIG = XORIG3D
        YORIG = YORIG3D
        XCELL = XCELL3D
        YCELL = YCELL3D
        VGTYP = VGTYP3D
        VGTOP = VGTOP3D
        VGLEV( : )  = VGLVS3D( : )
    END IF
    
    IF ( .NOT.OPEN3( 'METCRO2D', FSREAD3, PNAME ) ) THEN
        CALL M3EXIT( PNAME, 0,0, 'Could not OPEN3(METCRO2D,...)', 2 )
    ELSE IF ( .NOT.DESC3( 'METCRO2D' ) ) THEN
        CALL M3EXIT( PNAME, 0,0, 'Could not DESC3(METCRO2D)', 2 )
    ELSE IF ( .NOT.FILCHK3( 'METCRO2D',  GRDDED3,NCOLS, NROWS, 1, 1 ) ) THEN
        CALL M3EXIT( PNAME, 0,0, 'Inconsistent dimensions  for "METCRO2D"', 2 )
    ELSE IF ( .NOT.GRDCHK3( 'METCRO2D',                                &amp;
                            P_ALP, P_BET, P_GAM, XCENT, YCENT,      &amp;
                            XORIG, YORIG, XCELL, YCELL,             &amp;
                            1, VGTYP, VGTOP, VGLEV ) ) THEN
        CALL M3EXIT( PNAME, 0,0, 'Inconsistent map-projection or grid for "METCRO2D"', 2 )
    END IF
    ...

    !!........  <I>Get SDATE, STIME, TSTEP, NRECS, BARFAC from the user:</I>
    
    CALL RUNSPEC( METFILE, .FALSE., SDATE, STIME, TSTEP, NRECS )
    BARFAC = GETVAL( 0.0, 1.0, 0.7071, 'Enter BARFAC' )
    ...

    !!........  <I>Open output file(s).  First, fill in FDESC...</I>
    ...
    NVARS3D = ...
    NLAYS3D = 1
    SDATE3D = SDATE
    STIME3D = STIME
    TSTEP3D = TSTEP
    ...
    VNAME3D(1) = 'BAR'
    VTYPE3D(1) = M3REAL
    UNITS3D(1) = 'Somethings'
    VDESC3D(1) = 'dingbat that plings the inghams'
    ...
    IF ( .NOT.OPEN3( 'OUTCRO2D', FSUNKN3, PNAME ) ) THEN
        CALL M3EXIT( PNAME, 0,0, 'Could not OPEN3(OUTCRO2D,...)', 2 )
    END IF
    ...

    !!........  <I>Allocate arrays</I>
    
    ALLOCATE ( TA2( NCOLS,NROWS ),      &amp;
               BAR( NCOLS,NROWS ),      &amp;
                QV( NCOLS,NROWS,NLAYS ), STAT = ISTAT
    IF ( ISTAT .NE. 0 ) THEN
        WRITE( MESG, '(A, I9)' ) 'Allocation failure:  STAT=', ISTAT
        CALL M3EXIT( PNAME, 0,0, MESG, 2 )
    END IF
    ...

    !!........  <I>Main processing loop</I>

    JDATE = SDATE
    JTIME = STIME
    DO N = 1, NRECS     !!  <I>loop on timesteps</I>
        ...
        IF ( .NOT.READ3( 'METCRO2D', 'TA2', JDATE, JTIME, 1, TA2 ) ) THEN
            MESG = 'ERROR reading "TA2" from "METCRO2D"'
            CALL M3EXIT( PNAME, 0,0, MESG, 2 )
        END IF
        IF ( .NOT.READ3( 'METCRO3D', 'QV', JDATE, JTIME, ALLAYS3, QV ) ) THEN
            MESG = 'ERROR reading "QV" from "METCRO3D"'
            CALL M3EXIT( PNAME, 0,0, MESG, 2 )
        END IF
        ...
        <I>[compute BAR from TA2,QV etc... using BARFAC, etc.]</I>
        ...
        IF ( .NOT.WRITE3( 'OUTCRO2D', 'BAR', JDATE, JTIME, BAR ) ) THEN
            MESG = 'ERROR writing "BAR" to "OUTCRO2D"'
            CALL M3EXIT( PNAME, 0,0, MESG, 2 )
        END IF
        ...
        CALL NEXTIME( JDATE, JTIME, TSTEP )

    END DO              !!  <I>end loop on timesteps</I>
    ...
    CALL M3EXIT( PNAME, 0, 0, 'Successful completion', 0 )

END PROGRAM FOO
</PRE>
<P>
</BLOCKQUOTE>


<HR> <!----------------------------------------------------------------->

<A HREF = "AA.html#intro" >
Previous:  <STRONG>I/O Introduction Chapter</STRONG>
</A><P>

<A HREF = "CHANGES.html" >
Next:  <STRONG>Changes from the Previous I/O&nbsp;API Version</STRONG>
</A><P>

<A HREF = "SAMPLE.html" >
Related:  <STRONG>Sample Programs</STRONG>
</A><P>

<A HREF = "AA.html">
To: <STRONG>Models-3/EDSS I/O&nbsp;API:   The Help Pages</STRONG>
</A><P>


<!--#include virtual="/INCLUDES/footer.html" -->

</BODY>
</HTML>

