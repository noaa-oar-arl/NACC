
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- "$Id: UNGRIDB.html 70 2017-11-30 15:05:43Z coats $" -->
<META NAME="MSSmartTagsPreventParsing" CONTENT="TRUE"> 
<TITLE> UNGRIDB() and UNGRIDI()</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" 
      TOPMARGIN="15" 
      MARGINHEIGHT="15" 
      LEFTMARGIN="15" 
      MARGINWIDTH="15">

<H1>    UNGRIDB() and UNGRIDI() </H1>

<H2> Fortran version: </H2>


    <BLOCKQUOTE>
    For I/O&nbsp;API Version&nbsp;3.2:   <VAR>UNGRIDB()</VAR> and
    <VAR>UNGRIDI()</VAR> are Fortran-90 generic routines with optionally
    1-D or 2-D <CODE>REAL</CODE> or <CODE>REAL*8</CODE>
    location-arguments, with <CODE>INTERFACE</CODE>s defined in
    <CODE>MODULE M3UTILIO</CODE>.<BR>
    12/1/2017:  Added forms with <CODE>IERR</CODE> argument for I/O&nbsp;API 3.2:
    <P>

    For previous I/O&nbsp;API versions, <CODE>UNGRIDB()</CODE> and
    <CODE>UNGRIDB()</CODE>  have the same argument list as I/O&nbsp;API
    Version&nbsp;3.2 single-indexed <CODE>REAL</CODE> forms, but do not
    have <CODE>INTERFACE</CODE>s (hence Fortran-77 style argument
    behavior).
    </BLOCKQUOTE>
<PRE>
    SUBROUTINE UNGRIDB( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NPTS2, XLOCR, YLOCR, NU1, CU1 )
    SUBROUTINE UNGRIDB( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NPTS2, XLOCD, YLOCD, NU1, CU1 )
    SUBROUTINE UNGRIDB( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NCOL2, NROW2, XGRDR, YGRDR, NU2, CU2 )
    SUBROUTINE UNGRIDB( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NCOL2, NROW2, XGRDD, YGRDD, NU2, CU2 )
    SUBROUTINE UNGRIDB( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NPTS2, XLOCR, YLOCR, NU1, CU1, IERR )
    SUBROUTINE UNGRIDB( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NPTS2, XLOCD, YLOCD, NU1, CU1, IERR )
    SUBROUTINE UNGRIDB( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NCOL2, NROW2, XGRDR, YGRDR, NU2, CU2, IERR )
    SUBROUTINE UNGRIDB( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NCOL2, NROW2, XGRDD, YGRDD, NU2, CU2, IERR )

    SUBROUTINE UNGRIDI( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NPTS2, XLOCR, YLOCR, NX1 )
    SUBROUTINE UNGRIDI( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NPTS2, XLOCD, YLOCD, NX1 )
    SUBROUTINE UNGRIDI( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NCOL2, NROW2, XGRDR, YGRDR, NX2 )
    SUBROUTINE UNGRIDI( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NCOL2, NROW2, XGRDD, YGRDD, NX2 )
    SUBROUTINE UNGRIDI( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NPTS2, XLOCR, YLOCR, NX1, IERR )
    SUBROUTINE UNGRIDI( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NPTS2, XLOCD, YLOCD, NX1, IERR )
    SUBROUTINE UNGRIDI( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NCOL2, NROW2, XGRDR, YGRDR, NX2, IERR )
    SUBROUTINE UNGRIDI( NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL,   &amp;
                        NCOL2, NROW2, XGRDD, YGRDD, NX2, IERR )

        INTEGER, INTENT(IN   ) :: NCOL1, NROW1
        REAL*8 , INTENT(IN   ) :: XORIG, YORIG, XCELL, YCELL
        INTEGER, INTENT(IN   ) :: NPTS2, NCOL2, NROW2
        REAL   , INTENT(IN   ) :: XLOCR( NPTS2 ),       YLOCR( NPTS2 )
        REAL   , INTENT(IN   ) :: XGRDR( NCOL1,NROW1 ), YGRDR( NCOL1,NROW1 )
        REAL*8 , INTENT(IN   ) :: XLOCD( NPTS ),        YLOCD( NPTS2 )
        REAL*8 , INTENT(IN   ) :: XGRDD( NCOL1,NROW1 ), YGRDD( NCOL1,NROW1 )
        INTEGER, INTENT(  OUT) :: NU1( 4,NPTS2 )
        INTEGER, INTENT(  OUT) :: NU2( 4,NCOL2,NROW2 )
        INTEGER, INTENT(  OUT) :: NX1( 4,NPTS2 )
        INTEGER, INTENT(  OUT) :: NX2( 4,NCOL2,NROW2 )
        REAL   , INTENT(  OUT) :: CU1( 4,NPTS2 )
        REAL   , INTENT(  OUT) :: CU2( 4,NCOL2,NROW2 )
        INTEGER, INTENT(  OUT) :: IERR

        !!  NCOL1, NROW1, XORIG, YORIG, XCELL, YCELL are defining
        !!  parameters for the output-grid for the matrix-transform;
        !!  NPTS2, NCOL2, NROW2, XLOC*, YLOC*, XGRD* amd YGRD* are
        !!  the dimensions and locations for the input-data for 
        !!  the matrix transform.
        !!  NU*, CU* are the indexes and coefficients for the bilinear
        !!  interpolation matrix
        !!  NX* are the indexes for the incidence matrix.
        !!  IERR counts out-of-grid errors; IERR=0 means no errors.
        

</PRE><P> 

<H2> C version:  none </H2>

<H2> Summary: </H2>

    <BLOCKQUOTE>

    For I/O&nbsp;API Version&nbsp;3.2 and later, generic versions of
    these routines are declared in <VAR>MODULE M3UTILIO</VAR>, for which
    the input arguments  <VAR>XLOC</VAR> and <VAR>YLOC</VAR> are either
    1-D or 2D, and are either <VAR>REAL</VAR> or  <VAR>REAL*8</VAR>. 
    Routines <CODE>UNGRIDBS1()</CODE> and <CODE>UNGRIDIS1()</CODE>
    (which have 1-D single-precision location-arguments) correspond to
    the routines from I/O&nbsp;API Version&nbsp;3.1 and earlier.
    <P>

    <CODE>UNGRIDB()</CODE> computes &quot;ungridding&quot; matrices used
    by subroutines <A HREF = "BMATVEC.html"><CODE>BMATVEC()</CODE> and 
    <CODE>BILIN()</CODE></A> to perform bilinear interpolation  from a
    grid to a set of target (e.g., point source) locations or a grid
    <BLOCKQUOTE>
    <VAR>{ &lt;XLOC(S),YLOC(S)&gt;: S=1,NPTS2 }</VAR>
    <VAR>{ &lt;XGRD(C,R),YGRD(C,R)&gt;: C=1,NCOL2, R=1,NROW2 }</VAR>
    </BLOCKQUOTE>, 
    after the form (simplest case:  non-layered set of points as 
    interpolation-target), so that for a variable
    <VAR>V1(NCOLS*NROWS)</VAR> single-indexed on the source grid,
    the value at<VAR>&lt;XLOC(S),YLOC(S)&gt;</VAR> is given by the formula
    <BLOCKQUOTE>
    <VAR>VNEW(S)</VAR> = 
        <STRONG>SUM<SUB>J = 1...4 </SUB></STRONG>
            [ <VAR>CU(J,S) V1( NU(J,S) )</VAR> ]
    </BLOCKQUOTE>
    More detail on the computation of these coefficients, etc., is
    given in the <A HREF = "BMATVEC.html">section on
    <CODE>BMATVEC()</CODE></A>.
    <P> 

    <CODE>UNGRIDI()</CODE> computes &quot;<EM>incidence matrix</EM>
    ungridding&quot; indices for grid-to-grid transformation from a grid
    to the set of target (e.g., point source) locations or a new grid,
    as specified above, i.e., so that for a variable
    <VAR>V1(NCOLS*NROWS)</VAR> single-indexed on the source grid,
    <BLOCKQUOTE>
    <VAR>VNEW(S)&nbsp;=&nbsp;V1(NX(S))</VAR> is the value at
    <VAR>&lt;XLOC(S),YLOC(S)&gt;</VAR>
    </BLOCKQUOTE>    
    <P>
    
    Note that for the versions without the <CODE>IERR</CODE> argument,
    <STRONG>it is the responsibility of the caller to ensure that the
    points <VAR>&lt;XLOC,YLOC&gt;</VAR> or <VAR>&lt;XGRD,YLGRD&gt;</VAR>
    are inside the grid; otherwise, it is the responsibility of the
    caller to check <CODE>IERR</CODE> and respond accordingly.</STRONG>
    <BR>
    If the points are not inside the grid, the code will make a &quot;best
    effort&quot; using &quot;extend-by-constant&quot; on the boundaries.       
    <P>

    <STRONG>See also</STRONG> subroutines
    <BLOCKQUOTE>
    <A HREF = "GCTP.html">GCTP</A> coordinate transformation routine
    from USGS
    <P>
    <A HREF = "GRID2XY.html"><CODE>GRID2XY()</CODE></A>:  
    Grid-cell-center coordinate transformation routinee in 
    <CODE>MODULE MODGCTP</CODE>
    <P>
    <A HREF="GRID2INDX.html"><CODE>GRID2INDX(), PNTS2INDX(), and
    INDXMULT()</CODE></A> &quot;New&quot; bilinear interpolation package             
             from <CODE><A HREF="MODGCTP.html">MODULE MODGCTP</A></CODE>
             <P>
    <A HREF = "BMATVEC.html">BMATVEC() and BILIN()</A>,
    <A HREF = "DMATVEC.html">DMATVE()C</A>,
    <A HREF = "PMATVEC.html">PMATVE()C</A>, and
    <A HREF = "SMATVEC.html">SMATVEC()</A>
    <P>
    </BLOCKQUOTE>
    and programs
    <BLOCKQUOTE>
    <A HREF = "MTXBLEND.html"><VAR>mtxblend</VAR></A>,
    <A HREF = "MTXBUILD.html"><VAR>mtxbuild</VAR></A>,
    <A HREF = "MTXCALC.html" ><VAR>mtxcalc</VAR></A>,
    <A HREF = "MTXCPLE.html" ><VAR>mtxcple</VAR></A>.
    </BLOCKQUOTE>
    <P> 

    </BLOCKQUOTE>

<H2> Fortran Usage: </H2>

    <BLOCKQUOTE>

    For Fortran-90 declarations and interface checking:    
    <PRE>
    <A HREF = "M3UTILIO.html">USE M3UTILIO</A>
    </PRE><P>
    
    See usage guide under <A HREF = "BMATVEC.html"><VAR>BMATVEC()</VAR></A>
    <P>

    </BLOCKQUOTE>

<HR> <!----------------------------------------------------------------->
    
<A HREF = "SETSPHERE.html" >
Previous:  <STRONG>SETSPHERE and SPHEREDAT</STRONG>
</A><P> 

<A HREF = "TRIMLEN.html" >
Previous:  <STRONG>TRIMLEN</STRONG>
</A><P> 

<A HREF = "UPCASE.html" >
Next:  <STRONG>UPCASE</STRONG>
</A><P> 

<A HREF = "AA.html#coordstuff"> 
Up: <STRONG>Coordinate and Grid Related Routines</STRONG> 
</A><P> 

<A HREF = "AA.html#utility"> 
Up: <STRONG>Utility Routines</STRONG> 
</A><P> 

<A HREF = "AA.html"> 
To: <STRONG>Models-3/EDSS I/O API:   The Help Pages</STRONG> 
</A><P> 

</BODY>
</HTML>

