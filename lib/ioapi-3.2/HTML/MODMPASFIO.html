
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- "$Id: MODMPASFIO.html 140 2019-11-27 22:51:15Z coats $" -->
<META NAME="MSSmartTagsPreventParsing" CONTENT="TRUE">
<TITLE>MODULE MODMPASFIO</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF"
      TOPMARGIN="15"
      MARGINHEIGHT="15"
      LEFTMARGIN="15"
      MARGINWIDTH="15">

<!--#include virtual="/INCLUDES/header.html" -->

<H1>    Fortran-90 <CODE>MODULE MODMPASFIO</CODE> </H1>

<H2>Summary</H2>

    <BLOCKQUOTE>

    <EM>New May-Nov 2017 for I/O&nbsp;API-3.2!!</EM>
    <P>
    Unstructured MPAS-grid descriptions; grid related utility routines; and
    I/O for MPAS-format netCDF.
    <P>

    </BLOCKQUOTE>

<H2><A NAME = "contents">Contents</A></H2>

    <BLOCKQUOTE>
    <DL>
        <DT>  <A HREF = "#notes">Notes and Limitations</A>
        <DT>  <A HREF = "#evars" >Environment Variables</A>
        <DT>  <A HREF = "#decl" >Declarations</A>
        <DD> <CODE>PARAMETER</CODE>s and public <CODE>MODULE</CODE>-variables
             describing the current MPAS grid.
             <P>
        <DT>  <A HREF = "#init" ><CODE>INITMPGRID()</CODE> and
                                 <CODE>INITREARTH()</CODE></A>
        <DD> module initialization; <CODE>SPHEREDIST()</CODE>
             earth-radius reset.
        <DT>  <A HREF = "#shut" ><CODE>SHUTMPGRID()</CODE></A>
        <DD> module shutdown, flushing and closing all files.
        <DT>  <A HREF = "#open" ><CODE>OPENMPAS()</CODE></A>
        <DD> open existing MPAS-format input or output file
        <DT>  <A HREF = "#creat"><CODE>CREATEMPAS()</CODE></A>
        <DD> create new MPAS-format output file
        <DT>  <A HREF = "#desc" ><CODE>DESCMPAS()</CODE></A>
        <DD> read header and return description for MPAS-format input file
        <DT>  <A HREF = "#step" ><CODE>READMPSTEPS()</CODE></A>
        <DD> Read MPAS-format ASCII timestep-value list from an MPAS-format
             file and convert to I/O&nbsp;API conventions.
        <DT>  <A HREF = "#wstep" ><CODE>WRITEMPSTEP()</CODE></A>
        <DD> Write timestep-value record to an MPAS-format file
             as MPAS-format ASCII
        <DT>  <A HREF = "#read" ><CODE>READMPAS()</CODE></A>
        <DD> read variable or time step of variable from MPAS-format
             input file
        <DT>  <A HREF = "#write"><CODE>WRITEMPAS()</CODE></A>
        <DD> write variable or time step of variable to MPAS-format
             output file
             <P>
        <DT>  <A HREF = "#find" ><CODE>FINDCELL()</CODE>
              and <CODE>FINDVRTX()</CODE></A>
        <DD> find subscript for MPAS-cell or MPAS-dual-cell containing
              the point <CODE>(ALAT,ALON)</CODE>
        <DT>  <A HREF = "#wght" ><CODE>ARC2MPAS()</CODE></A>
        <DD> compute 2-D and 3-D weights for arc-segment (e.g., for SMOKE)
        <DT>  <A HREF = "#cmatx"><CODE>MPCELLMATX()</CODE></A>
        <DD>  Create a sparse incidence matrix (or index-array) for
              MPAS-cell subscripts for set of points or a rectangular
              grid, for cell-based interpolation.
        <DT>  <A HREF = "#bmatx"><CODE>MPBARYMATX()</CODE></A>
        <DD> Create a 3-band sparse matrix for barycentric-linear
             interpolation to a set of points or a 2-D rectangular
             grid of points.
        <DT>  <A HREF = "#bmult"><CODE>MPBARYMULT()</CODE></A>
        <DD> Multiply a 3-band barycentric-linear sparse matrix 
             by an MPAS variable, to perform interpolation.
        <DT>  <A HREF = "#interp"><CODE>MPINTERP()</CODE></A>
        <DD> Interpolate an MPAS-grid variable to a point, set of
             points, or 2-D grid of points, using barycentric-linear
             interpolation for <CODE>REAL</CODE> variables, or
             cell-based interpolation for <CODE>INTEGER</CODE> variables.
        <DT>  <A HREF = "#dist" ><CODE>SPHEREDIST()</CODE></A>
        <DD> compute spherical-Earth distance from  <CODE>(LAT1,LON1)</CODE>
             to <CODE>(LAT2,LON2)</CODE> or from MPAS Earth-centered
             Cartesian <CODE>(X1,Y1,Z1)</CODE> to <CODE>(X2,Y2,Z2)</CODE>
        <DT>  <A HREF = "#date" ><CODE>MPSTR2DT()</CODE> and <CODE>MPDT2STR()</CODE></A>
        <DD> convert MPAS-format ASCII date&amp;time to/from I/O&nbsp;API
             convention date&amp;time <CODE>JDATE:JTIME</CODE>
    </DL>
    </BLOCKQUOTE>

<HR> <!- ------------------------------------------------------------- ->

<H2><A NAME = "notes">Notes and Limitations</A></H2>

    <OL>
        <LI> MPAS is a potentially-global unstructured-grid weather
             model that currently is being adapted for atmospheric
             chemistry, land-surface modeling, and other tasks.<BR>
             See <A HREF="https://mpas-dev.github.io/files/documents/MPAS-MeshSpec.pdf">
             https://mpas-dev.github.io/files/documents/MPAS-MeshSpec.pdf</A>
             for the MPAS grid and netCDF-file specifications.  Note
             that MPAS-netCDF-format files are <EM>quite</EM> complex
             (and not rigorously specified, as further described below).
             <P>
        <LI> <A HREF="https://www.unidata.ucar.edu/software/netcdf/docs/BestPractices.html">
             NetCDF Best Practices</A> have been published by the
             developers of netCDF for more than 25 years.  MPAS does not
             follow a number of them.  To the extent possible, we will
             &quot;glue in&quot; best-practice support for MPAS-format
             files created by this module.
             <P>
        <LI> This being a &quot;direct-access data format&quot;, it is
             entirely possible to write &quot;irregular&quot; time
             stepping (i.e., time stepping with variable time steps),
             partial time steps, or time-steps out of order, possibly
             (accidentally?) leaving &quot;gaps&quot; in MPAS-format
             files.
             <P>
             Neither MPAS nor netCDF has internal data structures
             adequate to detect such gaps.  <STRONG>It is your
             responsibility to detect such gaps in input data, and to
             take appropriate measures if such gaps exist.</STRONG>
             (NetCDF will &quot;fill&quot; the gaps with special values
             like <CODE>NF_FILL_INT=-2147483647</CODE>,
             <CODE>NF_FILL_REAL=9.9692099683868690e+36</CODE>, etc.)
             <P>
             <CODE>setenv MPAS_CHKFILL Y</CODE> to have such checks
             automatically performed by routine
             <CODE><A HREF="#read">READMPAS()</A></CODE>.
             <P>
        <LI> MPAS supports both Earth-sphere based and other modeling
             (which may or may not be periodic).  This
             <CODE>MODULE</CODE> supports only Earth-sphere based
             modeling and its files.
             <P>
        <LI> The MPAS specification mandates a number of grid related
             and indexing variables; this <CODE>MODULE</CODE> saves a
             copy of these mandatory variables from the
             <CODE>INITMPGRID()</CODE> initialization-file as
             <CODE>PUBLIC, PROTECTED</CODE> module-variables: see
             <A HREF = "#decl">the next section, below</A>.
             <P>
        <LI> Except for Earth-radius <CODE>REARTH</CODE>, which is mandated
             to be <CODE>DOUBLE PRECISION</CODE>, the MPAS specification
             does not specify the types for the mandatory variables.
             <CODE>MODULE&nbsp;MPASFIO</CODE> assumes that these
             variables are either  default <CODE>REAL</CODE> or
             <CODE>DOUBLE&nbsp;PRECISION</CODE> for coordinate related
             variables (converting the former to the latter internally,
             to match <CODE>REARTH</CODE>), or default
             <CODE>INTEGER</CODE> for index and ID variables.  <BR>
             <STRONG>It is possible that not all MPAS files will comply
             with this type-assignment.</STRONG>
             <P>
        <LI> MPAS uses units of radians for latitudes and longitudes
             internally, with 
             <CODE><BLOCKQUOTE>
             -&pi;/2 &le; lat &le; &pi;/2 <BR>
             0 &le; lon &le; 2 &pi;
             </BLOCKQUOTE></CODE>
             Everyone else uses either degrees, minutes, and
             seconds or real-number degrees, and (except for the WMO) in
             a fashion compliant with ISO Standard 6709. This
             <CODE>MODULE</CODE> uses real-number degrees in the range
             <CODE><BLOCKQUOTE>
             -90 &le; lat &le; 90 <BR>
             0 &le; lon &le; 360
             </BLOCKQUOTE></CODE>
             internally, and converts back and forth between that and
             the on-file MPAS radians usage.  Arguments to the routines
             are converted to this convention, as necessary.
             <P>
        <LI> The MPAS <CODE>(X,Y,Z)</CODE> coordinate system is relative
             to 3-D Cartesian axes with origin <CODE>X=Y=Z=0</CODE> at
             the center of the Earth, with units measured in meters.
             <BR>
             (This may seem strange...)
             <P>
        <LI> The triangles formed by connecting the cell-centers of the cells
             with the centers of the cells that bound that cell form the
             <STRONG>dual&nbsp;mesh</STRONG>, a decomposition of the region
             covered by the mesh into triangles.  The edges of the dual
             mesh are the segments connecting the cell-centers of  cells
             that bound each other, the vertices of the dual-mesh
             are the cell-centers of the original mesh, and the
             cell-centers of the dual mesh are the vertices of the
             original mesh.<BR>
             <EM>Kite areas</EM> are the intersections of the original
             cells with the cells of the dual mesh.
             <P>
        <LI> <EM>LIMITATION:</EM>  There may be problems with
             <CODE>FINDCELL()</CODE>, <CODE>FINDVRTX()</CODE>,
             <CODE>MPBARYMATX()</CODE>, <CODE>MPBARYMULT()</CODE>,
             and <CODE>MPINTERP()</CODE> when the domain is not
             whole-Earth (therefore having boundary-cells) and the
             requested operation is for a boundary cell or intersects
             a boundary cell or if the MPAS domain is not convex (e.g.,
             &quot;C-shaped&quot;)..
             <P>
        <LI> I/O&nbsp;API <CODE><A HREF="MODNCFIO.html">MODULE
             MODNCFIO</A></CODE> also provides facilities for describing
             and reading &quot;raw&quot; netCDF.  However, the paradigm
             in that module is open-action-close within each routine,
             whereas the paradigm here is to separate the actions from
             the opening and the closing, with one action per routine
             (the file remaining open until a <CODE>SHUTMPGRID()</CODE>
             call).  These two paradigms do not mix well:  attempting to
             open or close an already-open netCDF file can lead to
             strange-looking (e.g., &quot;double-free&quot;) failures.
             <P>
    </OL>

    <STRONG>See also</STRONG>
    <BLOCKQUOTE><DL>
        <DT> <A HREF = "https://mpas-dev.github.io/files/documents/MPAS-MeshSpec.pdf">
             <VAR>https://mpas-dev.github.io/files/documents/MPAS-MeshSpec.pdf</VAR></A>,
        <DD> for MPAS grid and netCDF-file specifications
        <P>
        <DT> <A HREF = "MODNCFIO.html"><CODE>MODULE MODNCFIO</CODE></A>,
        <DD> for netCDF declarations and &quot;raw netCDF&quot; file routines
        <DT> <A HREF = "MODWRFIO.html"><CODE>MODULE MODWRFIO</CODE></A>
        <DD> for WRF-related file routines
        <P>
        <DT> <VAR><STRONG>m3tools</STRONG></VAR> program
            <A HREF = "MPASDIFF.html"><STRONG><VAR>mpasdiff</VAR></STRONG></A>
        <DD> for MPAS-format-netCDF variable and layer-range-of-variable
             statistical comparisons
        <DT> <VAR><STRONG>m3tools</STRONG></VAR> program
            <A HREF = "MPASSTAT.html"><STRONG><VAR>mpasstat</VAR></STRONG></A>
        <DD> for MPAS-format-netCDF variable and layer-range-of-variable
             statistics
        <DT> <VAR><STRONG>m3tools</STRONG></VAR> program
            <A HREF = "MPASTOM3.html"><STRONG><VAR>mpastom3</VAR></STRONG></A>
        <DD> for interpolating variables from MPAS-format-netCDF files to
             GRIDDED I/O&nbsp;API files.
        <DT> <VAR><STRONG>m3tools</STRONG></VAR>sample program
             <A HREF = "MPASWTEST.html"><STRONG><VAR>mpaswtest</VAR></STRONG></A>.
        <DD> Example program for<A HREF = "#wght" ><CODE>ARC2MPAS()</CODE></A>
             MPAS-grid allocation of emissions line-sources.
    </DL></BLOCKQUOTE>
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H2><A NAME = "evars">Environment Variables</A></H2>

    <BLOCKQUOTE>
    <DL>
        <DT> <CODE>MPAS_VERBOSE</CODE> <VAR>Y N [N]</VAR>
        <DD> Generate verbose diagnostic log output?
        <P>
        <DT> <CODE>MPAS_CHKFILL</CODE> <VAR>Y N [Y]</VAR>
        <DD> Check data read in by <CODE>READMPAS()</CODE> against
             netCDF fill-values, to find potential &quot;holes&quot;?
        <P>
        <DT> Logical file names
        <DD> Following the usual I/O&nbsp;API
             <A HREF="LOGICALS.html">logical file name conventions</A>
             for the files used by routines <CODE>INITMPGRID(), OPENMPAS(),
             CREATEMPAS(), DESCMPAS(), READMPAS(), WRITEMPAS(), READMPSTEPS(),
             WRITEMPSTEP()</CODE>:<P>
             <CODE>setenv&nbsp;&lt;name&gt;&nbsp;&lt;file-path&gt;</CODE>
        <P>
    </DL>
    </BLOCKQUOTE>


    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H2><A NAME = "decl">Declarations</A>: Public Variables and <CODE>PARAMETER</CODE>s</H2>

    <STRONG><CODE>PARAMETER</CODE>s:</STRONG>
    <BLOCKQUOTE>
    <DL>
        <DT><CODE>INTEGER, PUBLIC, PARAMETER :: MPSTRLEN = 64</CODE>
        <DD> String length for use in MPAS formatted netCDF files
             (e.g., for MPAS formatted ASCII version and date-and-time
             strings)
        <P>

        <DT><CODE>INTEGER, PUBLIC, PARAMETER :: NMPASDIMS = 11</CODE>
        <DD> Number of &quot;standard&quot; MPAS-file dimensions for
             this module (which augments the MPAS-mandated list by
             adding standard time and vertical dimensions).
             <P>

             Note that <A HREF="#open"><CODE>OPENMPAS()</CODE></A> and
             <A HREF="#create"><CODE>CREATEMPAS()</CODE></A> have provisions
             for defining additional dimensions on a per-file basis.
             (Having a potentially open-ended set of dimensions and
             their names adds substantial complexity&nbsp;;-(&nbsp;).
        <P>
        <DT><CODE>INTEGER, PUBLIC, PARAMETER :: NMPASVARS = 36</CODE>
        <DD> Number of &quot;standard&quot; MPAS-file variables for
             this module.
        <P>
        <DT><CODE>INTEGER, PUBLIC, PARAMETER :: MXMPASVARS = 2048</CODE>
        <DD> Maximum number of MPAS-file variables for this module.
        <P>
        <DT><CODE>INTEGER, PUBLIC, PARAMETER :: MXMPASFILE = 64</CODE>
        <DD> Maximum number of MPAS-files for this module.
        <P>

        <DT><CODE>CHARACTER(LEN=16), PUBLIC, PARAMETER :: MPASDIMNAMES( NMPASDIMS )</CODE>
        <DD> Names of the &quot;standard&quot; MPAS-file dimensions:
        <PRE>
        Time                       !!  1
        TWO = 2                    !!  2
        StrLen = 64                !!  3
        nCells                     !!  4
        nEdges                     !!  5
        nVertices                  !!  6
        vertexDegree               !!  7
        maxEdges                   !!  8
        maxEdges2                  !!  9
        nVertLevels                !! 10
        nVertLevelsP1              !! 11
        </PRE>
        <P>

        <DT><CODE>CHARACTER(LEN=MPSTRLEN), PUBLIC, PARAMETER :: MPASVARNAMES( NMPASVARS )</CODE>
        <DD> Names of the &quot;standard&quot; MPAS-file variables, as specified by
        the <A HREF="https://mpas-dev.github.io/files/documents/MPAS-MeshSpec.pdf">MPAS
        Mesh Specification document</A>:
        <PRE>
        indexToCellID           !!  1
        indexToEdgeID           !!  2
        indexToVertexID         !!  3
        nEdgesOnCell            !!  4
        nEdgesOnEdge            !!  5
        cellsOnCell             !!  6
        edgesOnCell             !!  7
        verticesOnCell          !!  8
        cellsOnEdge             !!  9
        edgesOnEdge             !! 10
        verticesOnEdge          !! 11
        cellsOnVertex           !! 12
        edgesOnVertex           !! 13
        latCell                 !! 14
        lonCell                 !! 15
        latEdge                 !! 16
        lonEdge                 !! 17
        latVertex               !! 18
        lonVertex               !! 19
        xCell                   !! 20
        yCell                   !! 21
        zCell                   !! 22
        xEdge                   !! 23
        yEdge                   !! 24
        zEdge                   !! 25
        xVertex                 !! 26
        yVertex                 !! 27
        zVertex                 !! 28
        weightsOnEdge           !! 29
        dvEdge                  !! 30
        dcEdge                  !! 31
        angleEdge               !! 32
        areaCell                !! 33
        areaTriangle            !! 34
        kiteAreasOnVertex       !! 35
        meshDensity             !! 36
        </PRE>
        <P>
    </DL>
    </BLOCKQUOTE>
    <P>

    <STRONG><CODE>PUBLIC</CODE> Variables:</STRONG>
    <P>

    <BLOCKQUOTE>
    <EM>Note that these are <CODE>PROTECTED</CODE> variables:</EM>  as far as codes that
    <CODE>USE</CODE> this module are concerned, they are <STRONG>read-only</STRONG>,
    being set within the module by routine <A HREF =
    "#init"><CODE>INITMPGRID()</CODE></A>.<BR>
    We give here both the names of the <CODE>MODULE</CODE>-variables, and
    the (clumsier, more-verbose) on-file names as specified by the
    MPAS-grid specification-document.
    <P>
    <DL>
        <DT><CODE>CHARACTER*64 ONSPHERE</CODE>
        <DD> (MPAS-spec name <VAR>on_a_sphere</VAR>):  <CODE>YES</CODE> for on-sphere MPAS grids
        <P>
        <DT><CODE>CHARACTER*64 MESH_ID</CODE>
        <DD> (<VAR>mesh_id</VAR>):  ASCII string for grid name
        <P>
        <DT><CODE>CHARACTER*64 MESH_SPEC</CODE>
        <DD> (<VAR>mesh_spec</VAR>):  MPAS grid specification version
        <P>
        <DT><CODE>INTEGER  MPSTEPS</CODE>
        <DD> maximum timestep number in the file used by <CODE>INITMPGRID()</CODE>
        <P>
        <DT><CODE>INTEGER  MPCELLS</CODE>
        <DD> (<VAR>nCells</VAR>):  number of primary cells
             in the mesh for the file used by <CODE>INITMPGRID()</CODE>
        <P>
        <DT><CODE>INTEGER MPEDGES</CODE>
        <DD> (<VAR>nEdges</VAR>):  number of edges in the mesh
        <P>
        <DT><CODE>INTEGER  MPVRTXS</CODE>
        <DD> (<VAR>nVertices</VAR>):  number of vertices in the mesh
        <P>
       <DT><CODE>INTEGER  MPLVLS</CODE>
        <DD> (<VAR>nVertLevels</VAR>):  number of vertical levels
             in the input file used by INITMPGRID()
        <P>
        <DT><CODE>INTEGER  MPVORDR</CODE>
        <DD> (<VAR>vertexDegree</VAR>):  maximum number of
             cells (or edges) per vertex
        <P>
        <DT><CODE>INTEGER  MPBNDYC</CODE>
        <DD> (<VAR>maxEdges</VAR>):  maximum number of
             boundary-edges or vertices for any cell
        <P>
        <DT><CODE>REAL*8  REARTH</CODE>
        <DD> (<VAR>sphere_radius</VAR>):  Earth-radius (Meters)<BR>
             In the absence of initialization, the default for use by
             <CODE>SPHEREDIST()</CODE> is 6370,000 Meters.
        <P>
        <DT><CODE>INTEGER  MPDATES(MPSTEPS)</CODE>
        <DD> (from <VAR>xtime</VAR>):  Julian dates (coded <CODE>YYYYDDD</CODE>)
             for the time steps in the input file used by INITMPGRID()
        <P>
        <DT><CODE>INTEGER  MPTIMES(MPSTEPS)</CODE>
        <DD> (from <VAR>xtime</VAR>):  times (coded <CODE>HHMMSS</CODE>)
             for the time steps in the input file used by INITMPGRID()
        <P>
       <DT><CODE>INTEGER  CELLID(MPCELLS)</CODE>
        <DD> (<VAR>indexToCellID</VAR>): global cell-ID
        <P>
        <DT><CODE>INTEGER  EDGEID(MPEDGES)</CODE>
        <DD> (<VAR>indexToEdgeID</VAR>): global edge-ID
        <P>
        <DT><CODE>INTEGER  VRTXID(MPVRTXS)</CODE>
        <DD> (<VAR>indexToVertexID</VAR>):   global vertex-ID
        <P>
        <DT><CODE>INTEGER  NBNDYE(MPCELLS)</CODE>
        <DD> (<VAR>nEdgesOnCel</VAR>):  Number of boundary-edges on a given cell
        <P>
        <DT><CODE>INTEGER  NEDGEE(MPEDGES)</CODE>
        <DD> (<VAR>nEdgesOnEdge</VAR>):  Number of edges on a given edge.
             Used to reconstruct tangential velocities.
        <P>
        <DT><CODE>INTEGER  BNDYCELL(MPBNDYC, MPCELLS)</CODE>
        <DD> (<VAR>cellsOnCell</VAR>): indices of cells that are on the
             boundary of a given cell
        <P>
       <DT><CODE>INTEGER  BNDYEDGE(MPBNDYC, MPCELLS)</CODE>
        <DD> (<VAR>edgesOnCell</VAR>):  indices of edges that are on the
             boundary of a given cell
        <P>
        <DT><CODE>INTEGER BNDYVRTX(MPBNDYC, MPCELLS)</CODE>
        <DD> (<VAR>verticesOnCell</VAR>):  boundary-vertex indices for this cell
        <P>
        <DT><CODE>INTEGER   ECELLS(2, MPEDGES)</CODE>
        <DD> (<VAR>cellsOnEdge</VAR>):  cell-indices for cells bounding this edge
        <P>
        <DT><CODE>INTEGER   EVRTXS(2, MPEDGES)</CODE>
        <DD> (<VAR>verticesOnEdge</VAR>):    vertex-indices for vertices bounding this edge
        <P>
        <DT><CODE>INTEGER   VCELLS(MPVORDR, MPVRTXS)</CODE>
        <DD> (<VAR>verticesOnCell</VAR>):  indices of cells that radiate from a given vertex
        <P>
        <DT><CODE>INTEGER   VEDGES(MPVORDR, MPVRTXS)</CODE>
        <DD> (<VAR>edgesOnVertex</VAR>):    indices of edges that radiate from a given vertex
        <P>
       <DT><CODE>INTEGER EEDGES(2*MPBNDYC, MPEDGES)</CODE>
        <DD> (<VAR>edgesOnEdge</VAR>):  Edge indices used to reconstruct tangential velocities.
        <P>
        <DT><CODE>REAL*8  EWGHTS(2*MPBNDYC, MPEDGES)</CODE>
        <DD> (<VAR>weightsOnEdge</VAR>):  Weights used to reconstruct tangential velocities.
        <P>
        <DT><CODE>REAL*8  ALATC(MPCELLS)</CODE>
        <DD> (<VAR>latCell</VAR>): latitudes of cell-centers
        <P>
        <DT><CODE>REAL*8  ALONC(MPCELLS)</CODE>
        <DD> (<VAR>lonCell</VAR>): longitudes of cell-centers,
             normalized so that
             <CODE>0&nbsp;&le;&nbsp;lon&nbsp;&lt;&nbsp;360</CODE>
        <P>
        <DT><CODE>REAL*8  ALATE(MPEDGES)</CODE>
        <DD> (<VAR>latEdge</VAR>): latitudes of edge-centers
        <P>
        <DT><CODE>REAL*8  ALONE(MPEDGES)</CODE>
        <DD> (<VAR>lonEdge</VAR>): longitudes of edge-centers,
             normalized so that
             <CODE>0&nbsp;&le;&nbsp;lon&nbsp;&lt;&nbsp;360</CODE>
        <P>
       <DT><CODE>REAL*8  ALATV(MPVRTXS)</CODE>
        <DD> (<VAR>latVertex</VAR>): latitudes of vertices
        <P>
        <DT><CODE>REAL*8  ALONV(MPVRTXS)</CODE>
        <DD> (<VAR>lonVertex</VAR>): longitudes of vertices,
             normalized so that
             <CODE>0&nbsp;&le;&nbsp;lon&nbsp;&lt;&nbsp;360</CODE>
        <P>
        <DT><CODE>REAL*8  XCELL(MPCELLS) </CODE>
        <DD> (<VAR>xCell</VAR>):  <CODE>X</CODE>-coordinates of cell-centers
        <P>
        <DT><CODE>REAL*8  YCELL(MPCELLS)</CODE>
        <DD> (<VAR>yCell</VAR>): <CODE>Y</CODE>-coordinates of cell-centers
        <P>
        <DT><CODE>REAL*8  ZCELL(MPCELLS)</CODE>
        <DD> (<VAR>zCell</VAR>):  <CODE>Z</CODE>-coordinates of cell-centers
        <P>
        <DT><CODE>REAL*8  XEDGE(MPEDGES)</CODE>
        <DD> (<VAR>xEdge</VAR>): <CODE>X</CODE>-coordinates of edge-centers
        <P>
       <DT><CODE>REAL*8  YEDGE(MPEDGES)</CODE>
        <DD> (<VAR>yEdge</VAR>):  <CODE>Y</CODE>-coordinates of edge-centers
        <P>
        <DT><CODE>REAL*8  ZEDGE(MPEDGES)</CODE>
        <DD> (<VAR>zEdge</VAR>):  <CODE>Z</CODE>-coordinates of edge-centers
        <P>
        <DT><CODE>REAL*8  XVRTX(MPVRTXS)</CODE>
        <DD> (<VAR>xVertex</VAR>): <CODE>X</CODE>-coordinates of vertices
        <P>
        <DT><CODE>REAL*8  YVRTX(MPVRTXS)</CODE>
        <DD> (<VAR>yVertex</VAR>):  <CODE>Y</CODE>-coordinates of vertices
        <P>
        <DT><CODE>REAL*8  ZVRTX(MPVRTXS)</CODE>
        <DD> (<VAR>zVertex</VAR>):  <CODE>Z</CODE>-coordinates of vertices
        <P>
        <DT><CODE>REAL*8  DVEDGE(MPEDGES)</CODE>
        <DD> (<VAR>dvEdge</VAR>):  Distance in meters between the vertices
             that bound a given edge.
        <P>
       <DT><CODE>REAL*8  DCEDGE(MPEDGES)</CODE>
        <DD> (<VAR>dcEdge</VAR>):  Distance in meters between centers of the
             cells that bound a given edge
        <P>
        <DT><CODE>REAL*8  EANGLE(MPEDGES)</CODE>
        <DD> (<VAR>angleEdge</VAR>):  Angle in radians an edge's normal vector
             makes with the local eastward direction.
        <P>
        <DT><CODE>REAL*8  CAREAS(MPCELLS)</CODE>
        <DD> (<VAR>areaCell</VAR>):  Areas in square meters for a given cell
        <P>
        <DT><CODE>REAL*8  VAREAS(MPVRTXS)</CODE>
        <DD> (<VAR>areaTriangle</VAR>):  Area in square meters for the
             triangle of the dual mesh centered at the given vertex.
        <P>
        <DT><CODE>REAL*8  KAREAS(:MPVORDR,MPVRTXS)</CODE>
        <DD> (<VAR>kiteAreasOnVertex</VAR>):  area of the intersection
             of the dual-mesh triangle centered at the given vertex
             with the original-mesh cells that intersect it.
        <P>
        <DT><CODE>REAL*8  MSHDEN(MPCELLS)</CODE>
        <DD> (<VAR>meshDensity</VAR>):  Value of the generating density
             function at each cell center (used for irregular meshes)
        <P>
    </DL>
    </BLOCKQUOTE>
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "init"><CODE>LOGICAL FUNCTIONs INITMPGRID() and
INITREARTH()</CODE></A></H2>

    <BLOCKQUOTE>

    This is a generic function with two currently implemented forms,
    and an explicit variant:
    </BLOCKQUOTE>
    <PRE>
    LOGICAL FUNCTION INITREARTH( RADEARTH )
        REAL(8), INTENT( IN ) :: RADEARTH        !!  Earth-radius (Meters)

    LOGICAL FUNCTION INITMPGRID( FNAME )
        CHARACTER*(*), INTENT( IN ) :: FNAME    !!  logical file name

    LOGICAL FUNCTION INITMPGRID( NCELLS,           &amp;
                                 NEDGES,           &amp;
                                 NVRTXS,           &amp;
                                 NVLVLS,           &amp;
                                 NVORDR,           &amp;
                                 NBNDYC,           &amp;
                                 NBNDY2,           &amp;
                                 CELLID1,          &amp;
                                 EDGEID1,          &amp;
                                 VRTXID1,          &amp;
                                 NBNDYE1,          &amp;
                                 NEDGEE1,          &amp;
                                 BYCELL1,          &amp;
                                 BYEDGE1,          &amp;
                                 BYVRTX1,          &amp;
                                 ECELLS1,          &amp;
                                 EVRTXS1,          &amp;
                                 VCELLS1,          &amp;
                                 VEDGES1,          &amp;
                                 EEDGES1,          &amp;
                                 ALATC1,           &amp;
                                 ALONC1,           &amp;
                                 ALATE1,           &amp;
                                 ALONE1,           &amp;
                                 ALATV1,           &amp;
                                 ALONV1,           &amp;
                                 XCELL1,           &amp;
                                 YCELL1,           &amp;
                                 ZCELL1,           &amp;
                                 XEDGE1,           &amp;
                                 YEDGE1,           &amp;
                                 ZEDGE1,           &amp;
                                 XVRTX1,           &amp;
                                 YVRTX1,           &amp;
                                 ZVRTX1,           &amp;
                                 EWGHTS1,          &amp;
                                 DVEDGE1,          &amp;
                                 DCEDGE1,          &amp;
                                 EANGLE1,          &amp;
                                 CAREAS1,          &amp;
                                 VAREAS1,          &amp;
                                 KAREAS1,          &amp;
                                 MSHDEN1,          &amp;
                                 ONSPHERE1,        &amp;
                                 MESH_ID1,         &amp;
                                 MESH_SPEC1,       &amp;
                                 REARTH1 )

        INTEGER, INTENT( IN ) :: NCELLS                     !!  # of primary cells in the mesh
        INTEGER, INTENT( IN ) :: NEDGES                     !!  # of edges in the mesh
        INTEGER, INTENT( IN ) :: NVRTXS                     !!  # of vertices in the mesh
        INTEGER, INTENT( IN ) :: NVLVLS                     !!  # of vertical levels
        INTEGER, INTENT( IN ) :: NVORDR                     !!  max vertex-order:  # of cells/edges per vertex
        INTEGER, INTENT( IN ) :: NBNDYC                     !!  max # of vertices/edges per cell
        INTEGER, INTENT( IN ) :: NBNDY2                     !!  2 * max # of vertices/edges per cell
        INTEGER, INTENT( IN ) :: CELLID1( NCELLS )          !! (NCELLS): global cell-ID
        INTEGER, INTENT( IN ) :: EDGEID1( NEDGES )          !! (NEDGES): global edge-ID
        INTEGER, INTENT( IN ) :: VRTXID1( NVRTXS )          !! (NVRTXS): global vertex-ID
        INTEGER, INTENT( IN ) :: NBNDYE1( NCELLS )          !! (NCELLS): # of edges per cell
        INTEGER, INTENT( IN ) :: NEDGEE1( NEDGES )          !! (NEDGES): # of edges per edge 1(0 or 1)
        INTEGER, INTENT( IN ) :: BYCELL1( NBNDYC, NCELLS )  !! (NBNDYC,NCELLS): boundary-cell indices for this cell
        INTEGER, INTENT( IN ) :: BYEDGE1( NBNDYC, NCELLS )  !! (NBNDYC,NCELLS): boundary-edge indices for this cell
        INTEGER, INTENT( IN ) :: BYVRTX1( NBNDYC, NCELLS )  !! (NBNDYC,NCELLS): boundary-vertex indices for this cell
        INTEGER, INTENT( IN ) :: ECELLS1(      2,NEDGES )   !! (2,NEDGES): cell indices for this edge
        INTEGER, INTENT( IN ) :: EVRTXS1(      2,NEDGES )   !! (2,NEDGES): vertex indices for this edge
        INTEGER, INTENT( IN ) :: VCELLS1( NVORDR,NVRTXS )   !! (NVORDR,NVRTXS): Cell indices that radiate from a given vertex.
        INTEGER, INTENT( IN ) :: VEDGES1( NVORDR,NVRTXS )   !! (NVORDR,NVRTXS): Edge indices that radiate from a given vertex
        INTEGER, INTENT( IN ) :: EEDGES1( 2*NBNDYC,NEDGES ) !! (NBNDY2,NEDGES): Edge indices used to reconstruct tangential velocities.
        REAL(8), INTENT( IN ) ::  ALATC1( NCELLS )          !! (NCELLS):  latitude-degrees for cell-centers
        REAL(8), INTENT( IN ) ::  ALONC1( NCELLS )          !! (NCELLS): longitude-degrees for cell-centers
        REAL(8), INTENT( IN ) ::  ALATE1( NEDGES )          !! (NEDGES):  latitude-degrees for edge-centers
        REAL(8), INTENT( IN ) ::  ALONE1( NEDGES )          !! (NEDGES): longitude-degrees for edge-centers
        REAL(8), INTENT( IN ) ::  ALATV1( NVRTXS )          !! (NVRTXS):  latitude-degrees for vertices
        REAL(8), INTENT( IN ) ::  ALONV1( NVRTXS )          !! (NVRTXS): longitude-degrees for vertices
        REAL(8), INTENT( IN ) ::  XCELL1( NCELLS )          !! (NCELLS): X-coordinate for cell-centers
        REAL(8), INTENT( IN ) ::  YCELL1( NCELLS )          !! (NCELLS): Y-coordinate for cell-centers
        REAL(8), INTENT( IN ) ::  ZCELL1( NCELLS )          !! (NCELLS): Z-coordinate for cell-centers
        REAL(8), INTENT( IN ) ::  XEDGE1( NEDGES )          !! (NCELLS): X-coordinate for edge-centers
        REAL(8), INTENT( IN ) ::  YEDGE1( NEDGES )          !! (NCELLS): Y-coordinate for edge-centers
        REAL(8), INTENT( IN ) ::  ZEDGE1( NEDGES )          !! (NCELLS): Z-coordinate for edge-centers
        REAL(8), INTENT( IN ) ::  XVRTX1( NVRTXS )          !! (NVRTXS): X-coordinate for vertices
        REAL(8), INTENT( IN ) ::  YVRTX1( NVRTXS )          !! (NVRTXS): Y-coordinate for vertices
        REAL(8), INTENT( IN ) ::  ZVRTX1( NVRTXS )          !! (NVRTXS): Z-coordinate for vertice
        REAL(8), INTENT( IN ) :: EWGHTS1( 2*NBNDYC,NEDGES ) !! (NBNDY2,NEDGES): weights used to reconstruct tangential velocities.
        REAL(8), INTENT( IN ) :: DVEDGE1( NEDGES )          !! (NEDGES):  edge lengths 1(M)
        REAL(8), INTENT( IN ) :: DCEDGE1( NEDGES )          !! (NEDGES):  distance between the cell-centers that saddle a given edge 1(M)
        REAL(8), INTENT( IN ) :: EANGLE1( NEDGES )          !! (NEDGES):  angle from edge-normal vector to Easting
        REAL(8), INTENT( IN ) :: CAREAS1( NCELLS )          !! (NCELLS):  cell areas 1(M^2)
        REAL(8), INTENT( IN ) :: VAREAS1( NVRTXS )          !! (NVRTXS):  dual-mesh triangle areas 1(M^2)
        REAL(8), INTENT( IN ) :: KAREAS1( NVORDR, NVRTXS )  !! (NBNDYC,NCELLS):  kite-area:  intersection of cell with dual-cell centered at vertex
        REAL(8), INTENT( IN ) :: MSHDEN1( NCELLS )          !! (NCELLS):  mesh density 1(none)
        CHARACTER*64, OPTIONAL, INTENT( IN ) :: ONSPHERE1
        CHARACTER*64, OPTIONAL, INTENT( IN ) :: MESH_ID1
        CHARACTER*64, OPTIONAL, INTENT( IN ) :: MESH_SPEC1
        REAL(8),      OPTIONAL, INTENT( IN ) :: REARTH1    !!  Earth-radius (M)
    </PRE>
    <BLOCKQUOTE>

    The <CODE>INITREARTH()</CODE> form is used to re-initialize
    the Earth-radius for use in <A HREF="#dist"><CODE>SPHEREDIST()</CODE></A>,
    for the case that function is used in stand-alone form.
    <P>

    <EM><U>Preconditions for <CODE>INITMPGRID()</CODE>, first form:</U></EM>
    <BLOCKQUOTE><DL>
        <DT><CODE> USE MODMPASFIO</CODE>
        <P>
        <DT><CODE> setenv FNAME <VAR>path for input initialization file</VAR></CODE>
        <DD>for the first form
        <DT><CODE> setenv MPAS_VERBOSE T <VAR>or</VAR> F</CODE>
        <DD>to turn on verbose logging
        <DT><CODE> setenv MPAS_CHKFILL T <VAR>or</VAR> F</CODE>
        <DD>to turn on input-data checking (to detect &quot;gaps&quot;
            in the input data)
    </DL></BLOCKQUOTE>

    The first <CODE>INITMPGRID()</CODE> form is the &quot;usual&quot;
    one; it initializes all of the internal data structures from an
    input MPAS-format file <CODE>FNAME</CODE>, and must be called before
    one calls any of the other public routines except
    <CODE>SPHEREDIST()</CODE>.  This is the usual form (and the form you
    should use):  the MPAS grid specification is <STRONG>very
    complicated</STRONG>, and the MPAS-model-initialization software
    will get it correct for you; you should not normally go around
    re-inventing this wheel.
    <P>

    The second <CODE>INITMPGRID()</CODE> form is a for use with
    <STRONG>Fortran-90 keyword arguments</STRONG>, where a complete
    MPAS-grid specification is provided by arguments instead of from an
    MPAS-file header.<BR> 
    <U>This is not recommended</U> (after all, the MPAS-initialization
    program's authors have done this extremely tedious operation
    once&mdash;why re-invent that wheel?)  Note that for this form, you
    must correctly specify <EM>all</EM> of these arguments, and should
    do so by name, e.g.
    <PRE>
    FLAG = INITMPGRID( &amp;
                     NCELLS  = &lt;value&gt; &amp;
                     ...
                     REARTH1 = &lt;value&gt; &amp;
                     )
    </PRE>
    <P>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "shut"><CODE>SUBROUTINE SHUTMPGRID()</CODE></A></H2>

    <PRE>
    SUBROUTINE SHUTMPGRID( )
    </PRE>

    <BLOCKQUOTE>

    Flush and close all files opened by <CODE><A HREF="#init">INITMPGRID()</A></CODE>,
    <CODE><A HREF="#open">OPENMPAS()</A></CODE> or
    <CODE><A HREF="#create">CREATEMPAS()</A></CODE>, and deallocate and
    clear internal state variables and other data structures.
    <P>

    <EM><U>Preconditions:</U></EM>
    <BLOCKQUOTE><UL>
        <LI><CODE> USE MODMPASFIO</CODE>
            <P>
    </UL></BLOCKQUOTE>

    Should be called prior to program termination.
    <P>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "open"><CODE>OPENMPAS()</CODE></A></H2>

    <PRE>
    LOGICAL FUNCTION OPENMPAS( FNAME,FMODE )

        CHARACTER*(*), INTENT(IN   ) :: FNAME   !!  logical file name
        INTEGER      , INTENT(IN   ) :: FMODE   !!  mode: FSREAD3 or FSRDWR3
    </PRE>

    <BLOCKQUOTE>

    <EM><U>Preconditions:</U></EM>
    <BLOCKQUOTE><UL>
        <LI><CODE> USE MODMPASFIO</CODE>
            <P>
        <LI>Call <CODE>INITMPGRID()</CODE> before calling <CODE>OPENMPAS()</CODE>
        <P>
        <LI><CODE> setenv FNAME <VAR>path for input data file</VAR></CODE>
        <P>
    </UL></BLOCKQUOTE>

    This routine opens an existing MPAS-format netCDF file either for
    read-only or read-write, <CODE>FMODE&nbsp;=&nbsp;FSREAD3</CODE>, or
    <CODE>FMODE&nbsp;=&nbsp;FSRDWR3</CODE>, respectively.
    <P>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "create"><CODE>CREATEMPAS()</CODE></A></H2>

    <BLOCKQUOTE>

    This is a generic <CODE>LOGICAL FUNCTION</CODE> with two forms:

    </BLOCKQUOTE>

    <PRE>
    LOGICAL FUNCTION CREATEMPAS( FNAME,                            &amp;
                                 NVARS, VNAMES, VTYPES, VNDIMS,    &amp;
                                 VDNAME, VUNITS )
    LOGICAL FUNCTION CREATEMPAS( FNAME, NDIMS,  DNAMES, DSIZES,    &amp;
                                 NVARS, VNAMES, VTYPES, VNDIMS,    &amp;
                                 VDNAME, VUNITS )

        CHARACTER*(*), INTENT(IN   ) :: FNAME                       !!  logical file name
        INTEGER      , INTENT(IN   ) :: NDIMS                       !!  number of dimensions used
        CHARACTER*(*), INTENT(IN   ) :: DNAMES( NDIMS )             !!  dimension-names
        INTEGER      , INTENT(IN   ) :: DSIZES( NDIMS )             !!  dimension-values
        INTEGER      , INTENT(IN   ) :: NVARS                       !!  number of (extra) output variables
        CHARACTER*(*), INTENT(IN   ) :: VNAMES( NVARS )             !!  variable-names
        INTEGER      , INTENT(IN   ) :: VTYPES( NVARS )             !!  variabale-type M3REAL, etc...)
        INTEGER      , INTENT(IN   ) :: VNDIMS( NVARS )             !!  rank (number of dimensions)
        CHARACTER*(*), INTENT(IN   ) :: VDNAME( NDIMS,NVARS )       !!  names for dimensions used for the variables
        CHARACTER*(*), INTENT(IN   ), OPTIONAL :: VUNITS( NVARS )   !!  variable-units

    </PRE>

    <BLOCKQUOTE>

    <EM><U>Preconditions:</U></EM>
    <BLOCKQUOTE><UL>
        <LI><CODE> USE MODMPASFIO</CODE>
            <P>
        <LI>Call <CODE>INITMPGRID()</CODE> before calling <CODE>CREATEMPAS()</CODE>
        <P>
        <LI><CODE> setenv FNAME <VAR>path for output data file</VAR></CODE>
        <P>
        <LI><CODE>FNAME</CODE> must not already exist:  this is
             &quot;create a <U>new</U> file.&quot;
        <P>
    </UL></BLOCKQUOTE>

    This routine opens/creates a new MPAS-format netCDF file with the
    given (dimension+variables) specification, sets up all the standard
    dimensions and variables as well as any extra dimensions and
    variables specified by the argument-list, and writes the standard
    MPAS variables to that file.  If (recommended!) <CODE>OPTIONAL</CODE>
    argument <CODE>VUNITS</CODE> is present, its values will be written
    to the file-header as additional  metadata, thereby following
    &quot;NetCDF Best Practices&quot;.
    <P>

    The first form (without the dimension specifications) assumes that
    all the dimension-specifications are taken from the file used by
    <CODE>INITMPGRID()</CODE>, i.e., matching the module's
    <A HREF="#init"> internal grid description variables</A> described above.
    <P>

    <STRONG>NOTE:</STRONG>  <EM>See also</EM>
    <A HREF="MODNCFIO.html#create">MODULE MODNCFIO</A>
    routine <CODE>CREATENC()</CODE> for reading &quot;raw&quot; netCDF
    file descriptions.  <CODE>DESCNCVAR()</CODE> performs an
    open-read-close sequence, and therefore should not be used after an
    <CODE>INITMPGRID()</CODE> or <CODE>OPENMPAS()</CODE>  call for the
    same file.
     <P>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "desc"><CODE>DESCMPAS()</CODE></A></H2>

    <BLOCKQUOTE>

    This is a generic <CODE>LOGICAL FUNCTION</CODE> with two forms (these
    are necessary because while &quot;NetCDF Best Practices&quot; specifies
    that the <VAR>units</VAR> attribute should be available for all variables,
    the MPAS-netCDF specification does not, and many (most?) MPAS-netCDF
    files do not provide it.;-(&nbsp;)

    </BLOCKQUOTE>

    <PRE>
    LOGICAL FUNCTION DESCMPAS( FNAME, NRECS, NVARS, VNAMES, VTYPES,         &amp;
                               VNDIMS, VDSIZE, VDNAME )
    LOGICAL FUNCTION DESCMPAS( FNAME, NRECS, NVARS, VNAMES, VTYPES, VUNITS, &amp;
                               VNDIMS, VDSIZE, VDNAME )

        CHARACTER*(*), INTENT(IN   ) :: FNAME               !!  logical file name
        INTEGER      , INTENT(  OUT) :: NVARS               !!  number of (extra) output variables
        INTEGER      , INTENT(  OUT) :: NRECS               !!  number of time steps
        CHARACTER*(*), INTENT(  OUT) :: VNAMES( MXVARS3 )   !!  variable-names
        INTEGER      , INTENT(  OUT) :: VTYPES( MXVARS3 )   !!  variable-type M3REAL, etc...)
        CHARACTER*(*), INTENT(  OUT) :: VUNITS( NVARS )     !!  variable-units
        INTEGER      , INTENT(  OUT) :: VNDIMS( MXVARS3 )   !!  rank (number of dimensions)
        INTEGER      , INTENT(  OUT) :: VDSIZE( 7,MXVARS3 ) !!  list of dimensions
        CHARACTER*(*), INTENT(  OUT) :: VDNAME( 7,MXVARS3 ) !!  names for dimensions used for the variables
    </PRE>

    <BLOCKQUOTE>

    <EM><U>Preconditions:</U></EM>
    <BLOCKQUOTE><UL>
        <LI><CODE> setenv FNAME <VAR>path for data file</VAR></CODE>
        <P>
        <LI><CODE> USE MODMPASFIO</CODE>
            <P>
        <LI>Call <CODE>INITMPGRID()</CODE> and either
            <CODE>OPENMPAS(FNAME...)</CODE> or <CODE>CREATEMPAS(FNAME...)</CODE>
            before calling <CODE>DESCMPAS(FNAME...)</CODE>
        <P>
    </UL></BLOCKQUOTE>
    <P>

    This routine returns a variables-description for the file with logical name
    <CODE>FNAME</CODE>.  If the version with argument  <CODE>VUNITS</CODE>
    is used, but the units-attribute is not available in the file, the
    value <CODE>CMISS3=&quot;????????????????&quot;</CODE> is returned in
    that argument.
    <P>

    <STRONG>NOTE:</STRONG>  <EM>See also</EM>
    <A HREF="MODNCFIO.html#desc">MODULE MODNCFIO</A>
    routine <CODE>DESCNCVAR()</CODE> for reading &quot;raw&quot; netCDF
    file descriptions.  <CODE>DESCNCVAR()</CODE> performs an
    open-read-close sequence, and therefore should not be used after an
    <CODE>INITMPGRID()</CODE> or <CODE>OPENMPAS()</CODE>  call for the
    same file.
     <P>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "step"><CODE>READMPSTEPS()</CODE></A></H2>

    <PRE>
    LOGICAL FUNCTION READMPSTEPS( FNAME, VNAME, NSTEPS, MXSTEP, JDATES, JTIMES )

        CHARACTER*(*), INTENT(IN   ) :: FNAME               !!  logical file name
        CHARACTER*(*), INTENT(IN   ) :: VNAME               !!  time-variable name
        INTEGER      , INTENT(IN   ) :: MXSTEP              !!  array-dimension
        INTEGER      , INTENT(  OUT) :: NSTEPS              !!  number of actual timesteps
        INTEGER      , INTENT(  OUT) :: JDATES( MXSTEP )    !!  dates YYYYDDD
        INTEGER      , INTENT(  OUT) :: JTIMES( MXSTEP )    !!  times HHMMSS
    </PRE>

    <BLOCKQUOTE>

    <EM><U>Preconditions:</U></EM>
    <BLOCKQUOTE><UL>
        <LI><CODE> setenv FNAME <VAR>path for data file</VAR></CODE>
        <P>
        <LI><CODE> USE MODMPASFIO</CODE>
            <P>
        <LI> Call <CODE>INITMPGRID()</CODE> and either
             <CODE>OPENMPAS(FNAME...)</CODE> or <CODE>CREATEMPAS(FNAME...)</CODE>
             before calling <CODE>READMPSTEPS()</CODE>.
             <P>
        <LI> Date-&amp;-time variable <CODE>VNAME</CODE> in
             file <CODE>FNAME</CODE> must be <CODE>CHARACTER*64</CODE>,
             formatted according to MPAS ASCII <CODE>YYYY-MM-DD_HH:MM[:SS]</CODE>
             year-month-day-hour-minute-seconds conventions (seconds
             field optional).
    </UL></BLOCKQUOTE>
    <P>

    This routine reads the number of steps and the array of
    date-&amp;-time strings for the time-variable <CODE>VNAME</CODE>
    (often  <CODE>xTime</CODE> or <CODE>xtime</CODE>)
    from the file <CODE>FNAME</CODE>, converts them from MPAS
    ASCII-string convention to I/O&nbsp;API convention <CODE>INTEGER
    JDATE=YYYYDDD,JTIME=HHMMSS</CODE>, and returns the number of steps
    as <CODE>NSTEPS</CODE>, and the dates and times as arrays
    <CODE>JDATES(NSTEPS)</CODE> and <CODE>JTIMES(NSTEPS)</CODE>.
    <P>

    <STRONG><U>NOTE</U> that there is no MPAS-model guarantee that these
    form a regular time step sequence, nor that particular variables do
    not have &quot;gaps&quot;.</STRONG>  In order to get timestep-number
    <CODE>ISTEP</CODE> for use with <CODE>READMPAS(FNAME,ISTEP,VNAME...)</CODE>
    or <CODE>WRITEMPAS(FNAME,ISTEP,VNAME...)</CODE>, you may find it
    useful to use I/O&nbsp;API  2-tuple lookup-routine
    <A HREF="FINDS.html"><CODE>FIND2()</CODE></A>
    as follows (where note that <CODE>ISTEP&gt;0</CODE> for the case
    that <CODE>JDATE:JTIME</CODE> is available, and is negative
    otherwise):
    <PRE>
    ...
    IF ( .NOT.READMPSTEPS( FNAME, NSTEPS, MXSTEP, JDATES, JTIMES ) ) THEN
    ...
    ISTEP = FIND2( JDATE, JTIME, NSTEPS, JDATES, JTIMES )
    IF ( ISTEP .GT. 0 ) THEN
        IF ( .NOT.READMPAS( FNAME, ISTEP, VNAME, ... ) THEN
            ...
    ELSE    <EM>!!  file does not have JDATE:JTIME...</EM>
    ...
    </PRE>
    <P>

    <EM>See also</EM>
    <UL>
        <LI> <A HREF="#date"><CODE>MPSTR2DT()</CODE> and
             <CODE>MPDT2STR()</CODE></A>,below.
        <LI> <A HREF="#wstep"><CODE>WRITEMPSTEP()</CODE></A>, below.
        <LI> <A HREF="MODNCFIO.html#read"><CODE>READNCVAR()</CODE></A>
             for reading &quot;raw&quot; netCDF.
        <LI> <A HREF="MODNCFIO.html#write"><CODE>WRITENCVAR()</CODE></A>
             for writing &quot;raw&quot; netCDF.
    </UL>
    <P>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "wstep"><CODE>WRITEMPSTEP()</CODE></A></H2>

    <PRE>
    LOGICAL FUNCTION WRITEMPSTEP( FNAME, VNAME, ISTEP, JDATE, JTIME )

        CHARACTER*(*), INTENT(IN   ) :: FNAME       !!  logical file name
        CHARACTER*(*), INTENT(IN   ) :: VNAME       !!  time-variable name
        INTEGER      , INTENT(IN   ) :: ISTEP       !!  timestep-number (1,2,...)
        INTEGER      , INTENT(IN   ) :: JDATE       !!  date YYYYDDD
        INTEGER      , INTENT(IN   ) :: JTIME       !!  time HHMMSS
    </PRE>

    <BLOCKQUOTE>

    <EM><U>Preconditions:</U></EM>
    <BLOCKQUOTE><UL>
        <LI><CODE> setenv FNAME <VAR>path for data file</VAR></CODE>
        <P>
        <LI><CODE> USE MODMPASFIO</CODE>
            <P>
        <LI> Call <CODE>INITMPGRID()</CODE> and either
             <CODE>OPENMPAS(FNAME, FSRDWR3,...)</CODE> or <CODE>CREATEMPAS(FNAME...)</CODE>
             before calling <CODE>READMPSTEPS()</CODE>.
             <P>
        <LI> Date-&amp;-time variable <CODE>VNAME</CODE> in
             file <CODE>FNAME</CODE> must be <CODE>CHARACTER*64</CODE>,
             formatted according to MPAS ASCII <CODE>YYYY-MM-DD_HH:MM[:SS]</CODE>
             year-month-day-hour-minute-seconds conventions.
             <P>
    </UL></BLOCKQUOTE>

    This routine writes the  date-&amp;-time string for indicated
    <CODE>JDATE:JTIME</CODE> to the time-variable <CODE>VNAME</CODE> in
    the file <CODE>FNAME</CODE>, converting  from I/O&nbsp;API
    convention <CODE>INTEGER JDATE=YYYYDDD,JTIME=HHMMSS</CODE> to
    MPAS <CODE>YYYY-MM-DD_HH:MM:SS</CODE> ASCII-string convention.
    <P>

    <STRONG><U>NOTE</U> The MPAS data structures being as they are, it
    is your responsibility</STRONG> to calculate the timestep-number
    <CODE>ISTEP</CODE>.  For &quot;regular&quot; time stepping (with
    a fixed time step), you may find it useful to use I/O&nbsp;API
    timestep-number routine <A HREF="JSTEP3.html"><CODE>JSTEP3()</CODE></A>
    as follows:
    <PRE>
    <EM>!!  SDATE = starting date (YYYYDDD) for the file
    !!  STIME = starting time (HHMMSS)  for the file
    !!  TSTEP = time step     (HHMMSS)  for the file</EM>
    ...
    ISTEP = JSTEP3( SDATE, STIME, TSTEP, JDATE, JTIME )
    IF ( .NOT.WRITEMPSTEP( FNAME, 'xTime', ISTEP, JDATE, JTIME ) ) THEN
    ...
    </PRE>
    <P>

    <EM>See also</EM>
    <UL>
        <LI> <A HREF="#date"><CODE>MPSTR2DT()</CODE> and
             <CODE>MPDT2STR()</CODE></A>,below.
        <LI> <A HREF="#wstep"><CODE>WRITEMPSTEP()</CODE></A>, below.
        <LI> <A HREF="MODNCFIO.html#read"><CODE>READNCVAR()</CODE></A>
             for reading &quot;raw&quot; netCDF.
        <LI> <A HREF="MODNCFIO.html#write"><CODE>WRITENCVAR()</CODE></A>
             for writing &quot;raw&quot; netCDF.
    </UL>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "read"><CODE>READMPAS()</CODE></A></H2>

    <BLOCKQUOTE>

    This is a generic <CODE>LOGICAL FUNCTION</CODE> for reading either entire
    variables, or time steps of variables, from MPAS-formatted netCDF files
    that have been already opened by <CODE>OPENMPAS()</CODE> or
    <CODE>CREATEMPAS()</CODE>.
    <P>

    There are 50 implemented forms, for 0-D (scalar), 1-D, 2-D, 3-D, and
    4-D arrays of types <CODE>REAL*8</CODE> (&quot;double&quot;),  <CODE>REAL</CODE>,
    <CODE>INTEGER</CODE>, <CODE>INTEGER*2</CODE> (&quot;short&quot;), or
    <CODE>INTEGER*1</CODE> (&quot;byte&quot;), either without (&quot;whole-variable&quot;)
    or with time stepping:

    </BLOCKQUOTE>
    <PRE>
    !!  <EM>time independent forms:</EM>
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, DSCALAR )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, RSCALAR )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, ISCALAR )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, SSCALAR )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, BSCALAR )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, DARRAY1 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, RARRAY1 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, IARRAY1 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, SARRAY1 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, BARRAY1 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, DARRAY2 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, RARRAY2 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, IARRAY2 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, SARRAY2 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, BARRAY2 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, DARRAY3 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, RARRAY3 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, IARRAY3 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, SARRAY3 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, BARRAY3 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, DARRAY4 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, RARRAY4 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, IARRAY4 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, SARRAY4 )
    LOGICAL FUNCTION READMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, BARRAY4 )
    
    !!  <EM>time stepped forms:</EM>
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, DSCALAR )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, RSCALAR )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, ISCALAR )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, SSCALAR )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, BSCALAR )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, DARRAY1 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, RARRAY1 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, IARRAY1 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, SARRAY1 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, BARRAY1 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, DARRAY2 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, RARRAY2 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, IARRAY2 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, SARRAY2 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, BARRAY2 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, DARRAY3 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, RARRAY3 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, IARRAY3 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, SARRAY3 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, BARRAY3 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, DARRAY4 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, RARRAY4 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, IARRAY4 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, SARRAY4 )
    LOGICAL FUNCTION READMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, BARRAY4 )

        CHARACTER*(*), INTENT(IN   ) :: FNAME           !!  logical file name
        CHARACTER*(*), INTENT(IN   ) :: VNAME           !!  logical file name
        INTEGER      , INTENT(IN   ) :: ISTEP           !!  time step number (1, 2, ...)
        INTEGER      , INTENT(IN   ) :: NDIM1, NDIM2, NDIM3, NDIM4
        REAL*8       , INTENT(  OUT) :: DSCALAR
        REAL         , INTENT(  OUT) :: RSCALAR
        INTEGER      , INTENT(  OUT) :: ISCALAR
        INTEGER*2    , INTENT(  OUT) :: SSCALAR
        INTEGER*1    , INTENT(  OUT) :: BSCALAR
        REAL*8       , INTENT(  OUT) :: DARRAY1( NDIM1 )
        REAL         , INTENT(  OUT) :: RARRAY1( NDIM1 )
        INTEGER      , INTENT(  OUT) :: IARRAY1( NDIM1 )
        INTEGER*2    , INTENT(  OUT) :: SARRAY1( NDIM1 )
        INTEGER*1    , INTENT(  OUT) :: BARRAY1( NDIM1 )
        REAL*8       , INTENT(  OUT) :: DARRAY2( NDIM1, NDIM2 )
        REAL         , INTENT(  OUT) :: RARRAY2( NDIM1, NDIM2 )
        INTEGER      , INTENT(  OUT) :: IARRAY2( NDIM1, NDIM2 )
        INTEGER*2    , INTENT(  OUT) :: SARRAY2( NDIM1, NDIM2 )
        INTEGER*1    , INTENT(  OUT) :: BARRAY2( NDIM1, NDIM2 )
        REAL*8       , INTENT(  OUT) :: DARRAY3( NDIM1, NDIM2, NDIM3 )
        REAL         , INTENT(  OUT) :: RARRAY3( NDIM1, NDIM2, NDIM3 )
        INTEGER      , INTENT(  OUT) :: IARRAY3( NDIM1, NDIM2, NDIM3 )
        INTEGER*2    , INTENT(  OUT) :: SARRAY3( NDIM1, NDIM2, NDIM3 )
        INTEGER*1    , INTENT(  OUT) :: BARRAY3( NDIM1, NDIM2, NDIM3 )
        REAL*8       , INTENT(  OUT) :: DARRAY4( NDIM1, NDIM2, NDIM3, NDIM4 )
        REAL         , INTENT(  OUT) :: RARRAY4( NDIM1, NDIM2, NDIM3, NDIM4 )
        INTEGER      , INTENT(  OUT) :: IARRAY4( NDIM1, NDIM2, NDIM3, NDIM4 )
        INTEGER*2    , INTENT(  OUT) :: SARRAY4( NDIM1, NDIM2, NDIM3, NDIM4 )
        INTEGER*1    , INTENT(  OUT) :: BARRAY4( NDIM1, NDIM2, NDIM3, NDIM4 )
    </PRE>

    <BLOCKQUOTE>

    <EM><U>Preconditions:</U></EM>
    <BLOCKQUOTE><UL>
        <LI> <CODE>setenv FNAME <VAR>&lt;path for data file&gt;</VAR></CODE>
        <P>
        <LI> <CODE>USE MODMPASFIO</CODE>
            <P>
        <LI> Call <CODE>INITMPGRID()</CODE> and either
             <CODE>OPENMPAS(FNAME...)</CODE> or <CODE>CREATEMPAS(FNAME...)</CODE>
             before calling <CODE>READMPAS()</CODE>.
        <P>
        <LI> <CODE>setenv MPAS_CHKFILL Y</CODE> to enable input-data
             &quot;hole-detection&quot;
            <P>
    </UL></BLOCKQUOTE>

    <STRONG><U>NOTE&nbsp;1</U> The MPAS data structures being as they are,
    it is your responsibility to calculate the timestep-number</STRONG>
    <CODE>ISTEP</CODE>.  You may find it useful to use
    <A HREF="#step">READMPSTEPS()</A> together with I/O&nbsp;API
    2-tuple lookup-routine
    <A HREF="FINDS.html"><CODE>FIND2()</CODE></A>,
    or I/O&nbsp;API timestep-number routine
    <A HREF="JSTEP3.html"><CODE>JSTEP3()</CODE></A>
    (for the regular-timesteps-only case), as follows:
    <PRE>
    <EM>!!  <EM>SDATE = starting date (YYYYDDD)</EM>
    !!  <EM>STIME = starting time (HHMMSS)</EM>
    !!  <EM>TSTEP = time step     (HHMMSS)</EM>
    ...
    !!  general case:</EM>
    IF ( .NOT.READMPSTEPS( FNAME, NSTEPS, MXSTEP, JDATES, JTIMES ) ) THEN
    ...
    ISTEP = FIND2( JDATE, JTIME, NSTEPS, JDATES, JTIMES )
    IF ( ISTEP .GT. 0 ) THEN
        IF ( .NOT.READMPAS( FNAME, ISTEP, VNAME, ... ) THEN
        ...
    ELSE    <EM>!!  file does not have JDATE:JTIME...</EM>
    ...
    <EM>!!  regular-timestep-case only:</EM>
    ISTEP = JSTEP3( SDATE, STIME, TSTEP, JDATE, JTIME )
    IF ( .NOT.READMPAS( FNAME, ISTEP, VNAME, ...
    ...
    </PRE>

    <STRONG><U>NOTE&nbsp;2</U> It is also your responsibility to detect
    &quot;gaps&quot; in the input data</STRONG>, since the internal
    MPAS data structures are inadequate for doing so.
    <BLOCKQUOTE><CODE>
    setenv MPAS_CHKFILL Y
    </CODE></BLOCKQUOTE>
    will turn on such checking from within <CODE>READMPAS()</CODE>,
    at some computational cost
    <P>

    <EM>See also</EM>
    <UL>
        <LI> <A HREF="#step"><CODE>READMPSTEPS()</CODE></A>, above
        <LI> <A HREF="#wstep"><CODE>WRITEMPSTEP()</CODE></A>, above.
        <LI> <A HREF="MODNCFIO.html#read"><CODE>READNCVAR()</CODE></A>
             for reading &quot;raw&quot; netCDF.
        <LI> <A HREF="MODNCFIO.html#write"><CODE>WRITENCVAR()</CODE></A>
             for writing &quot;raw&quot; netCDF.
    </UL>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "write"><CODE>WRITEMPAS()</CODE></A></H2>

    <BLOCKQUOTE>

    This is a generic <CODE>LOGICAL FUNCTION</CODE> for writing either
    entire variables, or time steps of variables, to MPAS-formatted
    netCDF files that have been already opened by
    <CODE>CREATEMPAS()</CODE>, or by <CODE>OPENMPAS()</CODE> in
    read-write (<CODE>FMODE=FSRDWR3</CODE>) mode.
    <P>

    There are 50 implemented forms, for 0-D (scalar), 1-D, 2-D, 3-D, and
    4-D arrays of types <CODE>REAL*8</CODE> (&quot;double&quot;),  <CODE>REAL</CODE>,
    <CODE>INTEGER</CODE>, <CODE>INTEGER*2</CODE> (&quot;short&quot;), or
    <CODE>INTEGER*1</CODE> (&quot;byte&quot;), either without
    (&quot;whole-variable&quot;) or with time stepping:

    </BLOCKQUOTE>

    <PRE>
    !!  <EM>time independent forms:</EM>
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, DSCALAR )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, RSCALAR )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, ISCALAR )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, SSCALAR )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, BSCALAR )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, DARRAY1 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, RARRAY1 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, IARRAY1 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, SARRAY1 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, BARRAY1 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, DARRAY2 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, RARRAY2 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, IARRAY2 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, SARRAY2 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, BARRAY2 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, DARRAY3 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, RARRAY3 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, IARRAY3 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, SARRAY3 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, BARRAY3 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, DARRAY4 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, RARRAY4 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, IARRAY4 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, SARRAY4 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, BARRAY4 )
    
    !!  <EM>time stepped forms:</EM>
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, DSCALAR )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, RSCALAR )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, ISCALAR )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, SSCALAR )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, BSCALAR )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, DARRAY1 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, RARRAY1 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, IARRAY1 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, SARRAY1 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, BARRAY1 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, DARRAY2 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, RARRAY2 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, IARRAY2 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, SARRAY2 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, BARRAY2 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, DARRAY3 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, RARRAY3 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, IARRAY3 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, SARRAY3 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, BARRAY3 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, DARRAY4 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, RARRAY4 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, IARRAY4 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, SARRAY4 )
    LOGICAL FUNCTION WRITEMPAS( FNAME, ISTEP, VNAME, NDIM1, NDIM2, NDIM3, NDIM4, BARRAY4 )

        CHARACTER*(*), INTENT(IN   ) :: FNAME           !!  logical file name
        CHARACTER*(*), INTENT(IN   ) :: VNAME           !!  logical file name
        INTEGER      , INTENT(IN   ) :: ISTEP           !!  time step number (1, 2, ...)
        INTEGER      , INTENT(IN   ) :: NDIM1, NDIM2, NDIM3, NDIM4
        REAL*8       , INTENT(IN   ) :: DSCALAR
        REAL         , INTENT(IN   ) :: RSCALAR
        INTEGER      , INTENT(IN   ) :: ISCALAR
        INTEGER*2    , INTENT(IN   ) :: SSCALAR
        INTEGER*1    , INTENT(IN   ) :: BSCALAR
        REAL*8       , INTENT(IN   ) :: DARRAY1( NDIM1 )
        REAL         , INTENT(IN   ) :: RARRAY1( NDIM1 )
        INTEGER      , INTENT(IN   ) :: IARRAY1( NDIM1 )
        INTEGER*2    , INTENT(IN   ) :: SARRAY1( NDIM1 )
        INTEGER*1    , INTENT(IN   ) :: BARRAY1( NDIM1 )
        REAL*8       , INTENT(IN   ) :: DARRAY2( NDIM1, NDIM2 )
        REAL         , INTENT(IN   ) :: RARRAY2( NDIM1, NDIM2 )
        INTEGER      , INTENT(IN   ) :: IARRAY2( NDIM1, NDIM2 )
        INTEGER*2    , INTENT(IN   ) :: SARRAY2( NDIM1, NDIM2 )
        INTEGER*1    , INTENT(IN   ) :: BARRAY2( NDIM1, NDIM2 )
        REAL*8       , INTENT(IN   ) :: DARRAY3( NDIM1, NDIM2, NDIM3 )
        REAL         , INTENT(IN   ) :: RARRAY3( NDIM1, NDIM2, NDIM3 )
        INTEGER      , INTENT(IN   ) :: IARRAY3( NDIM1, NDIM2, NDIM3 )
        INTEGER*2    , INTENT(IN   ) :: SARRAY3( NDIM1, NDIM2, NDIM3 )
        INTEGER*1    , INTENT(IN   ) :: BARRAY3( NDIM1, NDIM2, NDIM3 )
        REAL*8       , INTENT(IN   ) :: DARRAY4( NDIM1, NDIM2, NDIM3, NDIM4 )
        REAL         , INTENT(IN   ) :: RARRAY4( NDIM1, NDIM2, NDIM3, NDIM4 )
        INTEGER      , INTENT(IN   ) :: IARRAY4( NDIM1, NDIM2, NDIM3, NDIM4 )
        INTEGER*2    , INTENT(IN   ) :: SARRAY4( NDIM1, NDIM2, NDIM3, NDIM4 )
        INTEGER*1    , INTENT(IN   ) :: BARRAY4( NDIM1, NDIM2, NDIM3, NDIM4 )
    </PRE>

    <BLOCKQUOTE>

    <EM><U>Preconditions:</U></EM>
    <BLOCKQUOTE><UL>
        <LI><CODE> setenv FNAME <VAR>&lt;path for data file&gt;</VAR></CODE>
        <P>
        <LI><CODE> USE MODMPASFIO</CODE>
            <P>
        <LI> Call <CODE>INITMPGRID()</CODE> and either
             <CODE>OPENMPAS(FNAME,FSRDWR3)</CODE> or <CODE>CREATEMPAS(FNAME...)</CODE>
             before calling <CODE>READMPAS()</CODE>.
        <P>
    </UL></BLOCKQUOTE>

    <STRONG><U>NOTES</U></STRONG>
    <UL>
        <LI> The MPAS data structures being as they are, <STRONG>it
             is your responsibility</STRONG> to calculate (or keep
             track of) the timestep-number <CODE>ISTEP</CODE>.  If you
             are using &quot;regular&quot; time stepping (i.e., with a
             constant time step), you may find it useful to use
             I/O&nbsp;API timestep-number routine
             <A HREF="JSTEP3.html"><CODE>JSTEP3()</CODE></A>
             as follows (where note that <CODE>ISTEP&lt;0</CODE> when
             <CODE>JDATE:JTIME</CODE> is not on the regular time step
             sequence defined by <CODE>SDATE:STIME:TSTEP</CODE>).:
    <PRE>
    <EM>!!  SDATE = starting date (YYYYDDD) for the file
    !!  STIME = starting time (HHMMSS)  for the file
    !!  TSTEP = time step     (HHMMSS)  for the file</EM>
    ...
    ISTEP = JSTEP3( SDATE, STIME, TSTEP, JDATE, JTIME )
    IF ( ISTEP .GT. 0 ) THEN
        IF ( .NOT.WRITEMPAS( FNAME, ISTEP, ...
    ...
    ELSE
    ...
    </PRE>
        <P>

        <LI> For per-time-step <CODE>WRITEMPAS()</CODE> calls, when
             all the calls for a particular time step are complete, you
             should use <CODE>WRITEMPSTEP()</CODE> to record the related
             MPAS-formatted-ASCII date and time to the time-variable in
             the file.
        <P>

        <LI> For time dependent variables, it is most efficient if you
             will write all the variables for a given time step in
             consecutive order, before going on to the next time
             step.<BR>
             <STRONG>It is  your responsibility to ensure that
             there are no &quot;gaps&quot; in the timesteps for the
             variables you write:</STRONG> MPAS-format internal data
             structures are inadequate to deal with that situation, if
             you (accidentally?) introduce such gaps.
             <P>

        <LI> <CODE>CREATEMPAS()</CODE> writes the &quot;standard&quot;
             variables to this file, so that MPAS-mandated task is
             already automated for you.  You only need to use
             <CODE>WRITEMPAS()</CODE> for the &quot;extra&quot;
             variables you have defined.
         <P>

        <LI>  See also <A HREF="MODNCFIO.html">MODULE MODNCFIO</A> routines
              <CODE>DESCNCVAR()</CODE> for reading netCDF file
              descriptions, and <CODE>READNCVAR()</CODE> for reading
              variables, or time steps of variables, from
              &quot;raw&quot; netCDF files.<BR> Note that these routines
              do a open-action-close sequence within each routine, and
              so are not compatible with the corresponding MPAS-file
              operations provided by this module (which presumes that
              once files are opened, they stay opened until you call
              <CODE>SHUTMPGRID()</CODE>); you should only call
              them prior to using <CODE>OPENMPAS()</CODE> (or you may
              have obscure &quot;double-free&quot; errors).
         <P>
    </UL>

    <EM>See also</EM>
    <UL>
        <LI> <A HREF="#step"><CODE>READMPSTEPS()</CODE></A>, above
        <LI> <A HREF="#wstep"><CODE>WRITEMPSTEP()</CODE></A>, above.
        <LI> <A HREF="MODNCFIO.html#read"><CODE>READNCVAR()</CODE></A>
             for reading &quot;raw&quot; netCDF.
        <LI> <A HREF="MODNCFIO.html#write"><CODE>WRITENCVAR()</CODE></A>
             for writing &quot;raw&quot; netCDF.
    </UL>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "find"><CODE>FINDCELL()</CODE> and <CODE>FINDVRTX()</CODE></A></H2>

    <BLOCKQUOTE>

    These are generic <CODE>LOGICAL FUNCTION</CODE>s with two forms each:

    </BLOCKQUOTE>

    <PRE>
    INTEGER FUNCTION FINDCELL( ALATF, ALONF )
    INTEGER FUNCTION FINDCELL( ALATD, ALOND )

    INTEGER FUNCTION FINDVRTX( ALATF, ALONF )
    INTEGER FUNCTION FINDVRTX( ALATD, ALOND )

        REAL   , INTENT( IN ) :: ALATF, ALONF
        REAL(8), INTENT( IN ) :: ALATD, ALOND
    </PRE>

    <BLOCKQUOTE>
    <DL>
        <DT> <CODE>FINDCELL()</CODE>:
        <DD> Find the subscript for the (unstructured) MPAS-grid cell that
             contains the point <CODE>(ALAT,ALON)</CODE>.
        <P>
        <DT> <CODE>FINDVRTX()</CODE>:
        <DD> Find the subscript for the vertex at the center of the
             dual-mesh cell that contains the point <CODE>(ALAT,ALON)</CODE>
             or equivalently find the subscript for the vertex closest
             to the point <CODE>(ALAT,ALON)</CODE>
        <P>
    </DL>
    These routines are OpenMP thread-safe.
    <P>

    <EM><U>Preconditions:</U></EM>
    <BLOCKQUOTE><UL>
        <LI><CODE> USE MODMPASFIO</CODE>
            <P>
        <LI>Call <CODE>INITMPGRID()</CODE> before calling
             <CODE>FINDCELL()</CODE> or <CODE>FINDVRTX()</CODE>
            <P>
    </UL></BLOCKQUOTE>
    <P>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "wght"><CODE>ARC2MPAS()</CODE></A></H2>

    <BLOCKQUOTE>

    This is a generic <CODE>LOGICAL FUNCTION</CODE> with four forms:

    </BLOCKQUOTE>

    <PRE>
    LOGICAL FUNCTION ARC2MPAS( LAT1, LON1, LAT2, LON2, NMAX, NSEGS, CELLS, WGT2D )
    LOGICAL FUNCTION ARC2MPAS( LAT1, LON1, HGT1, LAT2, LON2, HGT2,    &amp;
                               NLAYS, NMAX, ZGRID,                    &amp;
                               NSEGS, CELLS, WGT3D )
    LOGICAL FUNCTION ARC2MPAS( LAT1, LON1, HGT1, LAT2, LON2, HGT2,    &amp;
                               NLAYS, NMAX, ZGRID,                    &amp;
                               NSEGS, CELLS, WGT2D, ZBOTS, ZTOPS, WGT3D )
    LOGICAL FUNCTION ARC2MPAS( LAT1, LON1, HGT1, LAT2, LON2, HGT2,    &amp;
                               NLAYS, NMAX, ZGRID,                    &amp;
                               NSEGS, CELLS, WGT2D,                   &amp;
                               LAYLO, LAYHI, ZBOTS, ZTOPS, WGT3D )

        REAL   , INTENT(IN   ) :: LAT1, LON1, HGT1, LAT2, LON2, HGT2
        INTEGER, INTENT(IN   ) :: NLAYS, NMAX
        REAL   , INTENT(IN   ) :: ZGRID( NLAYS+1,MPCELLS ) !!  layer-surfaces (M a.s.l)
        INTEGER, INTENT(  OUT) :: NSEGS
        INTEGER, INTENT(  OUT) :: CELLS( NMAX )         !! horizontal-grid cells
        INTEGER, INTENT(  OUT) :: LAYLO( NMAX )         !! vertical-grid layer-ranges
        INTEGER, INTENT(  OUT) :: LAYHI( NMAX )
        REAL   , INTENT(  OUT) :: ZBOTS( NMAX )         !! vertical-grid elevation-ranges (M a.s.l)
        REAL   , INTENT(  OUT) :: ZTOPS( NMAX )
        REAL   , INTENT(  OUT) :: WGT2D( NMAX )         !! horizontal-grid segment-fractions
        REAL   , INTENT(  OUT) :: WGT3D( NLAYS, NMAX )  !! 3-D-grid segment-fractions
    </PRE>

    <BLOCKQUOTE>

    <EM><U>Preconditions:</U></EM>
    <BLOCKQUOTE><UL>
        <LI> <CODE>USE MODMPASFIO</CODE>
            <P>
        <LI> Call <CODE>INITMPGRID()</CODE> before calling <CODE>ARC2MPAS()</CODE>
        <P>
        <LI> The last two forms, involving 3-D <CODE>WGT3D</CODE>,
             require that the must supply the MPAS-grid 3-D variable
             <CODE>ZGRID</CODE> containing the level-surfaces for the
             3-D model.
    </UL></BLOCKQUOTE>
    <P>

    Computes weights for line-segment trajectories, e.g., for mobile
    source or aircraft emissions.
    <P>

    This routine intersects a segment from
    <CODE>(LAT1,LON1[,HGT1])</CODE> to <CODE>(LAT2,LON2[,HGT2])</CODE>
    with either the horizontal (2-D) MPAS grid structure or 3-D
    (horizontal+vertical) grid structure, and returns the corresponding
    weights and optionally the layer- and elevation-ranges
    <CODE>[LAYLO:LAYHI]</CODE> and <CODE>[ZBOTS:ZTOPS]</CODE> for
    allocating the segment to the cells it intersects (e.g., for use in
    SMOKE).
    <P>

    The last form is the &quot;instrumented 3-D&quot; variant, which provides
    additional diagnostic data.
    <P>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "cmatx"><CODE>MPCELLMATX()</CODE></A></H2>

    <BLOCKQUOTE>

    <CODE>MPCELLMATX()</CODE> is a generic routine for computing
    sparse &quot;incidence&quot; matrices for either a 1-D
    or a 2-D array of points.
    <P>
    </BLOCKQUOTE>

    <PRE>
    LOGICAL FUNCTION MPCELLMATX( NP, LAT1F, LON1F, KCELL1 )
    LOGICAL FUNCTION MPCELLMATX( NP, LAT1D, LON1D, KCELL1 )
    LOGICAL FUNCTION MPCELLMATX( NC, NR, LAT2F, LON2F, KCELL2 )
    LOGICAL FUNCTION MPCELLMATX( NC, NR, LAT2D, LON2D, KCELL2 )
        INTEGER, INTENT(IN   ) :: NP, NC, NR
        REAL,    INTENT(IN   ) :: LAT1F( NP )
        REAL,    INTENT(IN   ) :: LON1F( NP )
        REAL(8), INTENT(IN   ) :: LAT1D( NP )
        REAL(8), INTENT(IN   ) :: LON1D( NP )
        REAL,    INTENT(IN   ) :: LAT2F( NC,NR )
        REAL,    INTENT(IN   ) :: LON2F( NC,NR )
        REAL(8), INTENT(IN   ) :: LAT2D( NC,NR )
        REAL(8), INTENT(IN   ) :: LON2D( NC,NR )
        INTEGER, INTENT(  OUT) ::  KCELL1( NP )   !! indices
        INTEGER, INTENT(  OUT) ::  KCELL2( NC,NR )
    </PRE>

    <BLOCKQUOTE>
    See also <A HREF="#bmatx"><CODE>MPBARYMATX()</CODE></A>
    aand <A HREF="#interp"><CODE>MPINTERP()</CODE></A> below.
    <P>

    Returns <CODE>TRUE</CODE> iff the interpolation can be done properly
    (i.e., if each point is contained in some MPAS-grid cell):  the
    basic property is that the points <CODE>(LAT*,LON*)</CODE> are
    contained in the MPAS-grid cell with subscript <CODE>KCELL*</CODE>.
    <P>
    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "bmatx"><CODE>MPBARYMATX()</CODE></A></H2>

    <BLOCKQUOTE>

    <CODE>MPBARYMATX()</CODE> is a generic routine for computing 3-band
    sparse matrices for  barycentric-linear interpolation to either a 1-D
    or a 2-D array of points, with optional weighting by the ratio of cell
    areas.
    <P>
    </BLOCKQUOTE>

    <PRE>
    LOGICAL FUNCTION MPBARYMATX( NP, LAT1F, LON1F, KCELL1, WCELL1F )
    LOGICAL FUNCTION MPBARYMATX( NP, LAT1D, LON1D, KCELL1, WCELL1D )
    LOGICAL FUNCTION MPBARYMATX( NP, LAT1D, LON1D, KCELL1, WCELL1F )
    LOGICAL FUNCTION MPBARYMATX( NC, NR, LAT2F, LON2F, KCELL2, WCELL2F )
    LOGICAL FUNCTION MPBARYMATX( NC, NR, LAT2D, LON2D, KCELL2, WCELL2D )
    LOGICAL FUNCTION MPBARYMATX( NC, NR, LAT2D, LON2D, KCELL2, WCELL2F )
    LOGICAL FUNCTION MPBARYMATX( NC, NR, LAT2F, LON2F, AF, KCELL2, WCELL2F )
    LOGICAL FUNCTION MPBARYMATX( NC, NR, LAT2D, LON2D, AD, KCELL2, WCELL2D )
    LOGICAL FUNCTION MPBARYMATX( NC, NR, LAT2D, LON2D, AD, KCELL2, WCELL2F )
    LOGICAL FUNCTION MPBARYMATX( NC, NR, LAT2F, LON2F, AGRDF, KCELL2, WCELL2F )
    LOGICAL FUNCTION MPBARYMATX( NC, NR, LAT2D, LON2D, AGRDD, KCELL2, WCELL2D )
    LOGICAL FUNCTION MPBARYMATX( NC, NR, LAT2D, LON2D, AGRDD, KCELL2, WCELL2F )
        INTEGER, INTENT(IN   ) :: NP, NC, NR
        REAL,    INTENT(IN   ) :: LAT1F( NP )
        REAL,    INTENT(IN   ) :: LON1F( NP )
        REAL(8), INTENT(IN   ) :: LAT1D( NP )
        REAL(8), INTENT(IN   ) :: LON1D( NP )
        REAL,    INTENT(IN   ) :: LAT2F( NC,NR )
        REAL,    INTENT(IN   ) :: LON2F( NC,NR )
        REAL(8), INTENT(IN   ) :: LAT2D( NC,NR )
        REAL(8), INTENT(IN   ) :: LON2D( NC,NR )
        REAL,    INTENT(IN   ) :: AF                !! output-grid cell areas (M^2)
        REAL(8), INTENT(IN   ) :: AD
        REAL,    INTENT(IN   ) :: AGRDF( NC,NR )
        REAL(8), INTENT(IN   ) :: AGRDD( NC,NR )
        INTEGER, INTENT(  OUT) ::  KCELL1( 3,NP )   !! indices
        INTEGER, INTENT(  OUT) ::  KCELL2( 3,NC,NR )
        REAL,    INTENT(  OUT) :: WCELL1F( 3,NP )   !! coefficients
        REAL(8), INTENT(  OUT) :: WCELL1D( 3,NP )
        REAL,    INTENT(  OUT) :: WCELL2F( 3,NC,NR )
        REAL(8), INTENT(  OUT) :: WCELL2D( 3,NC,NR )
    </PRE>

    <BLOCKQUOTE>
    See also <A HREF="#cmatx"><CODE>MPCELLMATX()</CODE></A> above
    aand <A HREF="#interp"><CODE>MPINTERP()</CODE></A> below.
    <P>

    Returns <CODE>TRUE</CODE> iff the interpolation can be done properly
    (i.e., if each point is surrounded by MPAS-grid cell-centers).
    <P>

    Calls using output-grid cell-area arguments
    <CODE>A&nbsp;=&nbsp;AF,AD,AGRDF,AGRDD</CODE> re-normalize the output
    result by the ratio of the relevant cell-areas <CODE>A*/CAREA</CODE>
    so that the emissions-per-grid-cell-per... units for emissions are
    retained.
    <P>

    The interpolation uses barycentric-coordinate linear interpolation
    on the dual-cell (triangle whose corners are MPAS-cell centers) that
    contains the requested point(s).  See
    <A HREF="https://codeplea.com/triangular-interpolation">https://codeplea.com/triangular-interpolation</A>
    for a reference on the interpolation formulas.
    <P>

    OpenMP parallel.  Code for the matrix:variable multiplication
    interpolation algorithm has the following pattern (shown for the
    1-D non-layered REAL case):
    </BLOCKQUOTE>

    <PRE>
    REAL    :: Z( MPCELLS )   !!  MPAS variable to be interpolated
    REAL    :: V( NP )        !!  result
    INTEGER :: P
    ...
    DO P = 1, NP
        K1 = KCELL1(  1,P )
        K2 = KCELL1(  2,P )
        K3 = KCELL1(  3,P )
        W1 = WCELL1F( 1,P )
        W2 = WCELL1F( 2,P )
        W3 = WCELL1F( 3,P )
        V( P ) = W1 * Z( K1 ) + W2 * Z( K2 ) + W3 * Z( K3 )
    END DO
    </PRE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "bmult"><CODE>MPBARYMULT()</CODE></A></H2>

    <BLOCKQUOTE>
    This is a generic routine for multiplying 3-band barycentric-linear 
    interpolation matrices from <CODE>MPBARYMATX()</CODE> (above) with
    possibly-layered MPAS-grid variables.
    <P>

    Note that layered results keep the MPAS-convention
    layer-subscript-first subscript ordering.
    <P>

    OpenMP parallel.
    </BLOCKQUOTE>

    <PRE>
    SUBROUTINE MPBARYMULT( NP,         KCELL1, WCELL1F, Z1F, V1F )
    SUBROUTINE MPBARYMULT( NP,         KCELL1, WCELL1D, Z1D, V1D )
    SUBROUTINE MPBARYMULT( NP, NL,     KCELL1, WCELL1F, ZLF, V1LF )
    SUBROUTINE MPBARYMULT( NP, NL,     KCELL1, WCELL1D, ZLD, V1LD )
    SUBROUTINE MPBARYMULT( NC, NR,     KCELL2, WCELL2F, Z1F, V2F )
    SUBROUTINE MPBARYMULT( NC, NR,     KCELL2, WCELL2D, Z1D, V2D )
    SUBROUTINE MPBARYMULT( NC, NR, NL, KCELL2, WCELL2F, ZLF, V2LF )
    SUBROUTINE MPBARYMULT( NC, NR, NL, KCELL2, WCELL2D, ZLD, V2LD )
        INTEGER, INTENT(IN   ) :: NP, NC, NR, NL
        INTEGER, INTENT(IN   ) ::  KCELL1( 3,NP )
        REAL,    INTENT(IN   ) :: WCELL1F( 3,NP )
        REAL(8), INTENT(IN   ) :: WCELL1D( 3,NP )
        INTEGER, INTENT(IN   ) ::  KCELL2( 3,NC,NR )
        REAL,    INTENT(IN   ) :: WCELL2F( 3,NC,NR )
        REAL(8), INTENT(IN   ) :: WCELL2D( 3,NC,NR )
        REAL,    INTENT(IN   ) :: Z1F( MPCELLS )        !!  MPAS variable to be interpolated
        REAL(8), INTENT(IN   ) :: Z1D( MPCELLS )
        REAL,    INTENT(IN   ) :: ZLF( NL,MPCELLS )
        REAL(8), INTENT(IN   ) :: ZLD( NL,MPCELLS )
        REAL,    INTENT(  OUT) ::  V1F( NP )             !!  result
        REAL(8), INTENT(  OUT) ::  V1D( NP )
        REAL,    INTENT(  OUT) :: V1LF( NL,NP )
        REAL(8), INTENT(  OUT) :: V1LD( NL,NP )
        REAL,    INTENT(  OUT) ::  V2F( NC,NR )
        REAL(8), INTENT(  OUT) ::  V2D( NC,NR )
        REAL,    INTENT(  OUT) :: V2LF( NC,NR,NL )
        REAL(8), INTENT(  OUT) :: V2LD( NC,NR,NL )
    </PRE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "interp"><CODE>MPINTERP()</CODE></A></H2>

    <BLOCKQUOTE>

    This is a generic routine for interpolating possibly-layered
    MPAS-grid variables to Lat-Lon specified points, sets of points,
    or (2-D) grids of points, with optional area-re-weighting for
    emissions data with &quot;per-cell&quot; units, using
    barycentric-linear interpolation.
    <P>
    </BLOCKQUOTE>

    <PRE>
    <EM>INTEGER forms</EM>
    LOGICAL FUNCTION MPINTERP( LATR0, LONR0, IZ, IV0 )
    LOGICAL FUNCTION MPINTERP( LATD0, LOND0, IZ, IV0 )
    LOGICAL FUNCTION MPINTERP( LATR0, LONR0, NLAY, IZL, IVL0 )
    LOGICAL FUNCTION MPINTERP( LATD0, LOND0, NLAY, IZL, IVL0 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, LATR2, LONR2, IZ, IV2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, LATD2, LOND2, IZ, IV2 )
    LOGICAL FUNCTION MPINTERP( NPTS, LATR1, LONR1, IZ, IV1 )
    LOGICAL FUNCTION MPINTERP( NPTS, LATD1, LOND1, IZ, IV1 )
    LOGICAL FUNCTION MPINTERP( NPTS, LATR1, LONR1, NLAY, IZL, IVL1 )
    LOGICAL FUNCTION MPINTERP( NPTS, LATD1, LOND1, NLAY, IZL, IVL1 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, LATR2, LONR2, NLAY, IZL, IVL2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, LATD2, LOND2, NLAY, IZL, IVL2 )

    <EM>Normal REAL forms</EM>
    LOGICAL FUNCTION MPINTERP( LATR0, LONR0, RZ, RV0 )
    LOGICAL FUNCTION MPINTERP( LATD0, LOND0, RZ, RV0 )
    LOGICAL FUNCTION MPINTERP( LATR0, LONR0, NLAY, RZL, RVL0 )
    LOGICAL FUNCTION MPINTERP( LATD0, LOND0, NLAY, RZL, RVL0 )
    LOGICAL FUNCTION MPINTERP( NPTS, LATR1, LONR1, RZ, RV1 )
    LOGICAL FUNCTION MPINTERP( NPTS, LATD1, LOND1, RZ, RV1 )
    LOGICAL FUNCTION MPINTERP( NPTS, LATR1, LONR1, NLAY, RZL, RVL1 )
    LOGICAL FUNCTION MPINTERP( NPTS, LATD1, LOND1, NLAY, RZL, RVL1 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, LATR2, LONR2, RZ, RV2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, LATD2, LOND2, RZ, RV2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, LATR2, LONR2, NLAY, RZL, RVL2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, LATD2, LOND2, NLAY, RZL, RVL2 )

    <EM>Cell-area re-weighting REAL forms</EM>
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, AR, LATR2, LONR2, RZ, RV2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, AD, LATD2, LOND2, RZ, RV2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, AR, LATR2, LONR2, NLAY, RZL, RVL2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, AD, LATD2, LOND2, NLAY, RZL, RVL2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, AGR, LATR2, LONR2, RZ, RV2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, AGD, LATD2, LOND2, RZ, RV2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, AGR, LATR2, LONR2, NLAY, RZL, RVL2 )
    LOGICAL FUNCTION MPINTERP( NCOL, NROW, AGD, LATD2, LOND2, NLAY, RZL, RVL2 )
        INTEGER, INTENT(IN   ) :: NPTS
        INTEGER, INTENT(IN   ) :: NCOL, NROW
        INTEGER, INTENT(IN   ) :: NLAY                !!  number of (MPAS-variable) layers
        REAL,    INTENT(IN   ) :: AR                  !!  area of output-grid cell
        REAL*8,  INTENT(IN   ) :: AD
        REAL,    INTENT(IN   ) :: AGR( NCOL,NROW )    !!  ...for Lat-Lon or non-regular grids
        REAL*8,  INTENT(IN   ) :: AGD( NCOL,NROW )
        REAL,    INTENT(IN   ) :: LATR0, LONR0
        REAL*8,  INTENT(IN   ) :: LATD0, LOND0
        REAL,    INTENT(IN   ) :: LATR1( NPTS ), LONR1( NPTS )
        REAL*8,  INTENT(IN   ) :: LATD1( NPTS ), LOND1( NPTS )
        REAL,    INTENT(IN   ) :: LATR2( NCOL,NROW ), LONR2( NCOL,NROW )
        REAL*8,  INTENT(IN   ) :: LATD2( NCOL,NROW ), LOND2( NCOL,NROW )
        INTEGER, INTENT(IN   ) :: IZ( MPCELLS )       !!  MPAS-grid variable to be interpolated
        REAL,    INTENT(IN   ) :: RZ( MPCELLS )       !!  MPAS-grid variable to be interpolated
        INTEGER, INTENT(IN   ) :: IZL( NLAY,MPCELLS )  !!  layered...
        REAL,    INTENT(IN   ) :: RZL( NLAY,MPCELLS )  !!  layered...
        REAL,    INTENT(  OUT) :: RV0                  !!  result of interpolation
        INTEGER, INTENT(  OUT) :: IV0
        REAL,    INTENT(  OUT) :: RV1( NPTS )
        INTEGER, INTENT(  OUT) :: IV1( NPTS )
        REAL,    INTENT(  OUT) :: RV2( NCOL,NROW )
        INTEGER, INTENT(  OUT) :: IV2( NCOL,NROW )
        REAL,    INTENT(  OUT) :: RVL0( NLAY )
        INTEGER, INTENT(  OUT) :: IVL0( NLAY )
        REAL,    INTENT(  OUT) :: RVL1( NLAY,NPTS )
        INTEGER, INTENT(  OUT) :: IVL1( NLAY,NPTS )
        REAL,    INTENT(  OUT) :: RVL2( NLAY,NCOL,NROW )
        INTEGER, INTENT(  OUT) :: IVL2( NLAY,NCOL,NROW )
    </PRE>

    <BLOCKQUOTE>

    Returns <CODE>TRUE</CODE> iff the interpolation can be done properly
    (i.e., if each point is surrounded by MPAS-grid cell-centers).  Note
    that <CODE>Z</CODE> variables are subscripted by the number
    <CODE>MPCELLS</CODE> of MPAS grid cells, and that layered results
    keep the MPAS-convention layer-subscript-first subscript ordering.
    <P>

    The interpolation uses barycentric-coordinate linear interpolation
    on the dual-cell (triangle whose corners are MPAS-cell centers) that
    contains the requested point(s).  See
    <A HREF="https://codeplea.com/triangular-interpolation">https://codeplea.com/triangular-interpolation</A>
    for a reference on the interpolation formulas.
    <P>

    Calls using output-grid cell-area arguments
    <CODE>A&nbsp;=&nbsp;AR,AD,AGR,AGD</CODE> re-normalize the output
    result by the ratio of the relevant cell-areas <CODE>A*/CAREA</CODE>
    so that the emissions-per-grid-cell-per... units for emissions are
    retained.
    <P>

    Note that this routine combines the functionality of
    <A HREF="#bmatx"><CODE>MPBARYMATX()</CODE></A> and <A
    HREF="#bmult"><CODE>MPBARYMULT()</CODE></A> (above) but
    always computes the interpolation weights and indices in-line. As a
    result it simpler to use, but less efficient for repeated uses than
    those routines.
    <P>

    For all but the single-point case, <CODE>MPINTERP()</CODE> is
    OpenMP-parallel.
    <P>

    <EM>See also</EM> <STRONG><VAR>m3tools</VAR></STRONG> program
    <A HREF="MPASTOM3.html"><STRONG><VAR>mpastom3</VAR></STRONG></A>.
    <P>
    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->


<H2><A NAME = "dist"><CODE>SPHEREDIST()</CODE></A></H2>

    <BLOCKQUOTE>

    This is a (potentially-stand-alone) generic <CODE>FUNCTION</CODE>
    for distance between two Lat-Lon specified or MPAS-Cartesian
    specified points on the Earth, with eight forms:

    </BLOCKQUOTE>

    <PRE>
    REAL    FUNCTION SPHEREDIST( RRADIUS, RLAT1, RLON1, RLAT2, RLON2 )
    REAL(8) FUNCTION SPHEREDIST( DRADIUS, DLAT1, DLON1, DLAT2, DLON2 )
    REAL    FUNCTION SPHEREDIST( RLAT1, RLON1, RLAT2, RLON2 )
    REAL(8) FUNCTION SPHEREDIST( DLAT1, DLON1, DLAT2, DLON2 )
    REAL    FUNCTION SPHEREDIST( RLAT1, RLON1, RLAT2, RLON2 )
    REAL(8) FUNCTION SPHEREDIST( DLAT1, DLON1, DLAT2, DLON2 )
    REAL    FUNCTION SPHEREDIST( RRADIUS, RX1, RY1, RZ1, RX2, RY2, RZ2 )
    REAL(8) FUNCTION SPHEREDIST( DRADIUS, DX1, DY1, DZ1, DX2, DY2, DZ2 )
    REAL    FUNCTION SPHEREDIST( RX1, RY1, RZ1, RX2, RY2, RZ2 )
    REAL(8) FUNCTION SPHEREDIST( DX1, DY1, DZ1, DX2, DY2, DZ2 )

        REAL   , INTENT( IN ) :: RRADIUS                    !! Earth-radius (Meters)
        REAL   , INTENT( IN ) :: RLAT1, RLON1, RLAT2, RLON2
        REAL(8), INTENT( IN ) :: DRADIUS                    !! Earth-radius (Meters)
        REAL(8), INTENT( IN ) :: RX1, RY1, RZ1, RX2, RY2, RZ2
        REAL   , INTENT( IN ) :: DX1, DY1, DZ1, DX2, DY2, DZ2
    </PRE>

    <BLOCKQUOTE>

    <EM><U>Precondition:</U></EM> <CODE> USE MODMPASFIO</CODE>
    <P>

    The forms with a <CODE>*RADIUS</CODE> arguments use a caller
    specified value for the radius of the Earth; the last two use the
    value from <CODE>MODULE</CODE>&mdash;variable <CODE>REARTH</CODE>,
    which either was set by 
    <CODE><A HREF="#init">INITMPGRID()</A></CODE> or was the
    module&mdash;default value (6370.0d3 meters).  The forms with
    <CODE>*LAT&mdash;*LON</CODE> arguments expect the point to be
    specified by Lat&mdash;Lon coordinates; the forms with 
    <CODE>*X*&mdash;*Y*&mdash;*Z*</CODE> arguments expect the point to
    be specified in the MPAS <CODE>X&mdash;Y&mdash;Z</CODE> 3&mdash;D
    Cartesian coordinate system.
    <P>

    Internally, the routines use the (numerically stable) Haversine
    formula for distance on a sphere; see
    <A HREF="https://en.wikipedia.org/wiki/Great-circle_distance">
    https://en.wikipedia.org/wiki/Great-circle_distance</A>
    <P>

    <EM>See also</EM> <A HREF="#init"><CODE>INITREARTH()</CODE></A> above,
    if you want to change the Earth-radius value.
    <P>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->



<H2><A NAME = "date"><CODE>MPSTR2DT()</CODE> and <CODE>MPDT2STR()</CODE></A></H2>

    <PRE>
    SUBROUTINE MPSTR2DT( CBUF, JDATE, JTIME )
        CHARACTER*(*), INTENT(IN   ) :: CBUF
        INTEGER      , INTENT(  OUT) :: JDATE, JTIME

    SUBROUTINE MPDT2STR( IDATE, ITIME, CSTR )
        INTEGER      , INTENT(IN   ) :: IDATE, ITIME
        CHARACTER*(*), INTENT(  OUT) :: CSTR
    </PRE>

    <BLOCKQUOTE>

    <EM><U>Precondition:</U></EM> <CODE> USE MODMPASFIO</CODE>
    <P>

    Dates and times on MPAS formatted files are stored in
    <CODE>CHARACTER(LEN=64)</CODE> strings, in the format
    <CODE>YYYY-MM-DD_HH:MM</CODE>, <CODE>YYYY-MM-DD_HH:MM:SS</CODE> or
    <CODE>YYYY-MM-DD_HH:MM:SS.SSS</CODE> using the (4-digit) year, and
    the 2-digit month, the 2-digit day-of-month, the 2-digit
    hour-of-day, the 2-digit minute-of-hour, and optionally the 2-digit
    seconds or 6-digit seconds.milliseconds.  These subroutines convert
    back and forth between this MPAS format and the I/O&nbsp;API
    <CODE>INTEGER</CODE> coded Julian-date&amp;time
    <CODE>YYYYDDD:HHMMSS</CODE>.
    <P>

    <EM>See also</EM> <A HREF="#step"><CODE>READMPSTEPS()</CODE></A> and
    <A HREF="#wstep"><CODE>WRITEMPSTEP()</CODE></A>, above.
    <P>

    </BLOCKQUOTE>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>

<HR> <!- ------------------------------------------------------------- ->

Copyright &copy; 2017 Carlie J. Coats, Jr., Ph.D.
    <BLOCKQUOTE>
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the <A HREF="https://www.gnu.org/licenses/fdl.html">GNU
    Free Documentation License, Version 1.3</A> or any later version
    published by the Free Software Foundation; with no Invariant
    Sections, no Front-Cover Texts, and no Back-Cover Texts.
    </BLOCKQUOTE>

<A HREF = "AA.html">
To: <STRONG>Models-3/EDSS I/O&nbsp;API:  The Help Pages</STRONG>
</A><P>
<P>


Send comments to
    <BLOCKQUOTE>
<A HREF = "mailto:carlie@jyarborough.com"> <ADDRESS>
          Carlie J. Coats, Jr. <br>
          carlie@jyarborough.com  </ADDRESS> </A>
    </BLOCKQUOTE><P>

<!--#include virtual="/INCLUDES/footer.html" -->


</BODY>
</HTML>


